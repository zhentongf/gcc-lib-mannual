<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstdc++: std::forward_list&lt; _Tp, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a05954.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a05951.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">std::forward_list&lt; _Tp, _Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for std::forward_list&lt; _Tp, _Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a05953.svg" width="190" height="136"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeeb9e091f2ec71ac3ec43ae40ad23cdc"><td class="memItemLeft" align="right" valign="top"><a id="aeeb9e091f2ec71ac3ec43ae40ad23cdc"></a>
typedef _Alloc&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:aeeb9e091f2ec71ac3ec43ae40ad23cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38c05af18474aef232c830dbe2faf4a"><td class="memItemLeft" align="right" valign="top"><a id="af38c05af18474aef232c830dbe2faf4a"></a>
typedef <a class="el" href="a05942.html">_Base::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:af38c05af18474aef232c830dbe2faf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab01dd2ce1c2c5b0fc9866eb0f6f2ee"><td class="memItemLeft" align="right" valign="top"><a id="a2ab01dd2ce1c2c5b0fc9866eb0f6f2ee"></a>
typedef <a class="el" href="a04978.html#a841791873537638dfc36c80ecc98bc48">_Alloc_traits::const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a2ab01dd2ce1c2c5b0fc9866eb0f6f2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fa3db3b2c1f48160a647833baf2c19"><td class="memItemLeft" align="right" valign="top"><a id="a23fa3db3b2c1f48160a647833baf2c19"></a>
typedef const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a23fa3db3b2c1f48160a647833baf2c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9fe5edb731512e042492ce69e0ab84"><td class="memItemLeft" align="right" valign="top"><a id="afb9fe5edb731512e042492ce69e0ab84"></a>
typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:afb9fe5edb731512e042492ce69e0ab84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370513d27eb915e900669a495235e770"><td class="memItemLeft" align="right" valign="top"><a id="a370513d27eb915e900669a495235e770"></a>
typedef <a class="el" href="a05938.html">_Base::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a370513d27eb915e900669a495235e770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75e12cd4c82b3fe6ac9b30385749660"><td class="memItemLeft" align="right" valign="top"><a id="ac75e12cd4c82b3fe6ac9b30385749660"></a>
typedef <a class="el" href="a04978.html#a4931a231115cbef628c29b147a7d7336">_Alloc_traits::pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:ac75e12cd4c82b3fe6ac9b30385749660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af415134f05e08c38882fdef7b7cebc95"><td class="memItemLeft" align="right" valign="top"><a id="af415134f05e08c38882fdef7b7cebc95"></a>
typedef value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:af415134f05e08c38882fdef7b7cebc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4d80899cdbf11e9d33980b19b033c6"><td class="memItemLeft" align="right" valign="top"><a id="a6e4d80899cdbf11e9d33980b19b033c6"></a>
typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a6e4d80899cdbf11e9d33980b19b033c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9402218544bbdc492896abf05081ff00"><td class="memItemLeft" align="right" valign="top"><a id="a9402218544bbdc492896abf05081ff00"></a>
typedef _Tp&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a9402218544bbdc492896abf05081ff00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2d179d6a061a4e6d8dcea244cdc29fe7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a2d179d6a061a4e6d8dcea244cdc29fe7">forward_list</a> ()=default</td></tr>
<tr class="separator:a2d179d6a061a4e6d8dcea244cdc29fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a366e3ba3ca40c479e0f33e664e6e7"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </td></tr>
<tr class="memitem:ac9a366e3ba3ca40c479e0f33e664e6e7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a05954.html#ac9a366e3ba3ca40c479e0f33e664e6e7">forward_list</a> (_InputIterator __first, _InputIterator __last, const _Alloc &amp;__al=_Alloc())</td></tr>
<tr class="separator:ac9a366e3ba3ca40c479e0f33e664e6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4876e29ab044344ca726a36b6cdca01b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a4876e29ab044344ca726a36b6cdca01b">forward_list</a> (const _Alloc &amp;__al) noexcept</td></tr>
<tr class="separator:a4876e29ab044344ca726a36b6cdca01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642ecbf961b6a99a7deb77e676e71cac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a642ecbf961b6a99a7deb77e676e71cac">forward_list</a> (const <a class="el" href="a05954.html">forward_list</a> &amp;__list)</td></tr>
<tr class="separator:a642ecbf961b6a99a7deb77e676e71cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db7e57854e789a4e93d7f12fbae8d69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a5db7e57854e789a4e93d7f12fbae8d69">forward_list</a> (const <a class="el" href="a05954.html">forward_list</a> &amp;__list, const __type_identity_t&lt; _Alloc &gt; &amp;__al)</td></tr>
<tr class="separator:a5db7e57854e789a4e93d7f12fbae8d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57eaebb7af37579e166cb2c2b753f53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#ac57eaebb7af37579e166cb2c2b753f53">forward_list</a> (<a class="el" href="a05954.html">forward_list</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ac57eaebb7af37579e166cb2c2b753f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34b172ec3558a231ee4193f98fd757d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#aa34b172ec3558a231ee4193f98fd757d">forward_list</a> (<a class="el" href="a05954.html">forward_list</a> &amp;&amp;__list, const __type_identity_t&lt; _Alloc &gt; &amp;__al) noexcept(_Node_alloc_traits::_S_always_equal())</td></tr>
<tr class="separator:aa34b172ec3558a231ee4193f98fd757d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950f84e93e993ce756a016954c4322db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a950f84e93e993ce756a016954c4322db">forward_list</a> (size_type __n, const _Alloc &amp;__al=_Alloc())</td></tr>
<tr class="separator:a950f84e93e993ce756a016954c4322db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dc09fa341ed4c54da852f6a430bba2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a81dc09fa341ed4c54da852f6a430bba2">forward_list</a> (size_type __n, const _Tp &amp;__value, const _Alloc &amp;__al=_Alloc())</td></tr>
<tr class="separator:a81dc09fa341ed4c54da852f6a430bba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925933047508f0bd16df276c4f0261e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a925933047508f0bd16df276c4f0261e4">forward_list</a> (<a class="el" href="a01878.html">std::initializer_list</a>&lt; _Tp &gt; __il, const _Alloc &amp;__al=_Alloc())</td></tr>
<tr class="separator:a925933047508f0bd16df276c4f0261e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c16633a2af635de7b7646ab8c29e46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a30c16633a2af635de7b7646ab8c29e46">~forward_list</a> () noexcept</td></tr>
<tr class="separator:a30c16633a2af635de7b7646ab8c29e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0bffb70955f72cf2972e70155e13d2"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </td></tr>
<tr class="memitem:aaf0bffb70955f72cf2972e70155e13d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a05954.html#aaf0bffb70955f72cf2972e70155e13d2">assign</a> (_InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:aaf0bffb70955f72cf2972e70155e13d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834314c2bf6e162dab99f07f1d6c551d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a834314c2bf6e162dab99f07f1d6c551d">assign</a> (size_type __n, const _Tp &amp;__val)</td></tr>
<tr class="separator:a834314c2bf6e162dab99f07f1d6c551d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaa8789d2741f6b65603b41c8aba63f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#adcaa8789d2741f6b65603b41c8aba63f">assign</a> (<a class="el" href="a01878.html">std::initializer_list</a>&lt; _Tp &gt; __il)</td></tr>
<tr class="separator:adcaa8789d2741f6b65603b41c8aba63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8f8d9f8c5572304785f24529c297c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05942.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a1b8f8d9f8c5572304785f24529c297c6">before_begin</a> () const noexcept</td></tr>
<tr class="separator:a1b8f8d9f8c5572304785f24529c297c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4becc964d2aa37c756215139094d8ff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05938.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a4becc964d2aa37c756215139094d8ff8">before_begin</a> () noexcept</td></tr>
<tr class="separator:a4becc964d2aa37c756215139094d8ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8913be197ae32ed6898686dfa3f1bfdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05942.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a8913be197ae32ed6898686dfa3f1bfdf">begin</a> () const noexcept</td></tr>
<tr class="separator:a8913be197ae32ed6898686dfa3f1bfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141f3a112d865e3125cb105b429c2a63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05938.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a141f3a112d865e3125cb105b429c2a63">begin</a> () noexcept</td></tr>
<tr class="separator:a141f3a112d865e3125cb105b429c2a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e747964c0b29e83f50020110f4b1d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05942.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a8e747964c0b29e83f50020110f4b1d72">cbefore_begin</a> () const noexcept</td></tr>
<tr class="separator:a8e747964c0b29e83f50020110f4b1d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace31decae76d75133e08418f392a78b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05942.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#ace31decae76d75133e08418f392a78b3">cbegin</a> () const noexcept</td></tr>
<tr class="separator:ace31decae76d75133e08418f392a78b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa651df81ec5161454becd5198407986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05942.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#aaa651df81ec5161454becd5198407986">cend</a> () const noexcept</td></tr>
<tr class="separator:aaa651df81ec5161454becd5198407986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88c1d40b71b3724ca63da3b66d4a5e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#aa88c1d40b71b3724ca63da3b66d4a5e0">clear</a> () noexcept</td></tr>
<tr class="separator:aa88c1d40b71b3724ca63da3b66d4a5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd1e68be8454830cea449ad8114cf3d"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a5fd1e68be8454830cea449ad8114cf3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a05938.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a05954.html#a5fd1e68be8454830cea449ad8114cf3d">emplace_after</a> (<a class="el" href="a05942.html">const_iterator</a> __pos, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a5fd1e68be8454830cea449ad8114cf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950aacf736d4f143794cacefbd742a7a"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a950aacf736d4f143794cacefbd742a7a"><td class="memTemplItemLeft" align="right" valign="top">reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a05954.html#a950aacf736d4f143794cacefbd742a7a">emplace_front</a> (_Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a950aacf736d4f143794cacefbd742a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a3479429315d1735f3d6b15817b01e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#ab0a3479429315d1735f3d6b15817b01e">empty</a> () const noexcept</td></tr>
<tr class="separator:ab0a3479429315d1735f3d6b15817b01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a320037c76fc8f0e6f60784dcec1383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05942.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a9a320037c76fc8f0e6f60784dcec1383">end</a> () const noexcept</td></tr>
<tr class="separator:a9a320037c76fc8f0e6f60784dcec1383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f64feff678dd8cb85d35bd9b08fde54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05938.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a7f64feff678dd8cb85d35bd9b08fde54">end</a> () noexcept</td></tr>
<tr class="separator:a7f64feff678dd8cb85d35bd9b08fde54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369164fbcb598a49bbd7297eb6f2c5b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05938.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a369164fbcb598a49bbd7297eb6f2c5b0">erase_after</a> (<a class="el" href="a05942.html">const_iterator</a> __pos)</td></tr>
<tr class="separator:a369164fbcb598a49bbd7297eb6f2c5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa779e251eac11a2d84fa9a2b65921bae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05938.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#aa779e251eac11a2d84fa9a2b65921bae">erase_after</a> (<a class="el" href="a05942.html">const_iterator</a> __pos, <a class="el" href="a05942.html">const_iterator</a> __last)</td></tr>
<tr class="separator:aa779e251eac11a2d84fa9a2b65921bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2daca181da8d9a22ecc19e4a7364b1f"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#aa2daca181da8d9a22ecc19e4a7364b1f">front</a> ()</td></tr>
<tr class="separator:aa2daca181da8d9a22ecc19e4a7364b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c8314a3fb6d46884588bcab67111b5"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a40c8314a3fb6d46884588bcab67111b5">front</a> () const</td></tr>
<tr class="separator:a40c8314a3fb6d46884588bcab67111b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66a5f239cf5fe9431700b756e711b4a"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#ab66a5f239cf5fe9431700b756e711b4a">get_allocator</a> () const noexcept</td></tr>
<tr class="separator:ab66a5f239cf5fe9431700b756e711b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cc027e568ad94dbbbc25da7d485fe7"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </td></tr>
<tr class="memitem:a03cc027e568ad94dbbbc25da7d485fe7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a05938.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a05954.html#a03cc027e568ad94dbbbc25da7d485fe7">insert_after</a> (<a class="el" href="a05942.html">const_iterator</a> __pos, _InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:a03cc027e568ad94dbbbc25da7d485fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde2adcdc4a7398d0179a9acd9933dd0"><td class="memItemLeft" align="right" valign="top"><a id="acde2adcdc4a7398d0179a9acd9933dd0"></a>
<a class="el" href="a05938.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_after</b> (<a class="el" href="a05942.html">const_iterator</a> __pos, _Tp &amp;&amp;__val)</td></tr>
<tr class="separator:acde2adcdc4a7398d0179a9acd9933dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8e1063932912fb3e245b7c8116ed1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05938.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a6f8e1063932912fb3e245b7c8116ed1f">insert_after</a> (<a class="el" href="a05942.html">const_iterator</a> __pos, const _Tp &amp;__val)</td></tr>
<tr class="separator:a6f8e1063932912fb3e245b7c8116ed1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4921af283fd230d563266ca0ce14a455"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05938.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a4921af283fd230d563266ca0ce14a455">insert_after</a> (<a class="el" href="a05942.html">const_iterator</a> __pos, size_type __n, const _Tp &amp;__val)</td></tr>
<tr class="separator:a4921af283fd230d563266ca0ce14a455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9739cbb5af18ac9976288f6c9c072bb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05938.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a9739cbb5af18ac9976288f6c9c072bb0">insert_after</a> (<a class="el" href="a05942.html">const_iterator</a> __pos, <a class="el" href="a01878.html">std::initializer_list</a>&lt; _Tp &gt; __il)</td></tr>
<tr class="separator:a9739cbb5af18ac9976288f6c9c072bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19c74808b1bc8e53bdc229fd3d389fa"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#ae19c74808b1bc8e53bdc229fd3d389fa">max_size</a> () const noexcept</td></tr>
<tr class="separator:ae19c74808b1bc8e53bdc229fd3d389fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4794e46af448c443019e9b36640744ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a4794e46af448c443019e9b36640744ab">merge</a> (<a class="el" href="a05954.html">forward_list</a> &amp;&amp;__list)</td></tr>
<tr class="separator:a4794e46af448c443019e9b36640744ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de7b075b73cc0a843447ad75cba4b87"><td class="memTemplParams" colspan="2">template&lt;typename _Comp &gt; </td></tr>
<tr class="memitem:a0de7b075b73cc0a843447ad75cba4b87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a05954.html#a0de7b075b73cc0a843447ad75cba4b87">merge</a> (<a class="el" href="a05954.html">forward_list</a> &amp;&amp;__list, _Comp __comp)</td></tr>
<tr class="separator:a0de7b075b73cc0a843447ad75cba4b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2e8369ed2d6b846842cd6f153d6745"><td class="memItemLeft" align="right" valign="top"><a id="a0e2e8369ed2d6b846842cd6f153d6745"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>merge</b> (<a class="el" href="a05954.html">forward_list</a> &amp;__list)</td></tr>
<tr class="separator:a0e2e8369ed2d6b846842cd6f153d6745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21960d00c20f7c502b03727f38a95510"><td class="memTemplParams" colspan="2"><a id="a21960d00c20f7c502b03727f38a95510"></a>
template&lt;typename _Comp &gt; </td></tr>
<tr class="memitem:a21960d00c20f7c502b03727f38a95510"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>merge</b> (<a class="el" href="a05954.html">forward_list</a> &amp;__list, _Comp __comp)</td></tr>
<tr class="separator:a21960d00c20f7c502b03727f38a95510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c1273fb53228cab655addd77f9cd25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05954.html">forward_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a78c1273fb53228cab655addd77f9cd25">operator=</a> (const <a class="el" href="a05954.html">forward_list</a> &amp;__list)</td></tr>
<tr class="separator:a78c1273fb53228cab655addd77f9cd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedecd0634ab8c057cca203778ea6cfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05954.html">forward_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#aaedecd0634ab8c057cca203778ea6cfa">operator=</a> (<a class="el" href="a05954.html">forward_list</a> &amp;&amp;__list) noexcept(_Node_alloc_traits::_S_nothrow_move())</td></tr>
<tr class="separator:aaedecd0634ab8c057cca203778ea6cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8dfcf0c3aad308699e909186c39f2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05954.html">forward_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a6b8dfcf0c3aad308699e909186c39f2b">operator=</a> (<a class="el" href="a01878.html">std::initializer_list</a>&lt; _Tp &gt; __il)</td></tr>
<tr class="separator:a6b8dfcf0c3aad308699e909186c39f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace75c01c591425341e21b6404e7f9e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#ace75c01c591425341e21b6404e7f9e90">pop_front</a> ()</td></tr>
<tr class="separator:ace75c01c591425341e21b6404e7f9e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164e352752ccca11cddb4270ea9df360"><td class="memItemLeft" align="right" valign="top"><a id="a164e352752ccca11cddb4270ea9df360"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (_Tp &amp;&amp;__val)</td></tr>
<tr class="separator:a164e352752ccca11cddb4270ea9df360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d708075d40071265f0a376591ba1d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#ac2d708075d40071265f0a376591ba1d7">push_front</a> (const _Tp &amp;__val)</td></tr>
<tr class="separator:ac2d708075d40071265f0a376591ba1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b3162769904b5c710868fa13e9b8b9"><td class="memItemLeft" align="right" valign="top">__remove_return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#aa9b3162769904b5c710868fa13e9b8b9">remove</a> (const _Tp &amp;__val)</td></tr>
<tr class="separator:aa9b3162769904b5c710868fa13e9b8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7f79f92d9199ce7245925b27621304"><td class="memTemplParams" colspan="2">template&lt;typename _Pred &gt; </td></tr>
<tr class="memitem:a7c7f79f92d9199ce7245925b27621304"><td class="memTemplItemLeft" align="right" valign="top">__remove_return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a05954.html#a7c7f79f92d9199ce7245925b27621304">remove_if</a> (_Pred __pred)</td></tr>
<tr class="separator:a7c7f79f92d9199ce7245925b27621304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8475e438a4c19df25362300acee87e8b"><td class="memTemplParams" colspan="2"><a id="a8475e438a4c19df25362300acee87e8b"></a>
template&lt;typename _Pred &gt; </td></tr>
<tr class="memitem:a8475e438a4c19df25362300acee87e8b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remove_if</b> (_Pred __pred) -&gt; __remove_return_type</td></tr>
<tr class="separator:a8475e438a4c19df25362300acee87e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ffca07b591237200b852caf7040057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a73ffca07b591237200b852caf7040057">resize</a> (size_type __sz)</td></tr>
<tr class="separator:a73ffca07b591237200b852caf7040057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb248e17d0392a8caf5c46683102332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#abfb248e17d0392a8caf5c46683102332">resize</a> (size_type __sz, const value_type &amp;__val)</td></tr>
<tr class="separator:abfb248e17d0392a8caf5c46683102332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab1413dfa1c6858634407a44504a368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a2ab1413dfa1c6858634407a44504a368">reverse</a> () noexcept</td></tr>
<tr class="separator:a2ab1413dfa1c6858634407a44504a368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb37711f3350692a1246d7781967ea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a4bb37711f3350692a1246d7781967ea6">sort</a> ()</td></tr>
<tr class="separator:a4bb37711f3350692a1246d7781967ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f59eaf1f58f480eafa906d68d408682"><td class="memTemplParams" colspan="2">template&lt;typename _Comp &gt; </td></tr>
<tr class="memitem:a3f59eaf1f58f480eafa906d68d408682"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a05954.html#a3f59eaf1f58f480eafa906d68d408682">sort</a> (_Comp __comp)</td></tr>
<tr class="separator:a3f59eaf1f58f480eafa906d68d408682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8918bd7e48f28df3b891edfc246556d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a8918bd7e48f28df3b891edfc246556d0">splice_after</a> (<a class="el" href="a05942.html">const_iterator</a> __pos, <a class="el" href="a05954.html">forward_list</a> &amp;&amp;__list) noexcept</td></tr>
<tr class="separator:a8918bd7e48f28df3b891edfc246556d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a2a989959206263a683014f575cdc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#aa3a2a989959206263a683014f575cdc3">splice_after</a> (<a class="el" href="a05942.html">const_iterator</a> __pos, <a class="el" href="a05954.html">forward_list</a> &amp;&amp;__list, <a class="el" href="a05942.html">const_iterator</a> __i) noexcept</td></tr>
<tr class="separator:aa3a2a989959206263a683014f575cdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa858318acd7f22d1f326b9473198e758"><td class="memItemLeft" align="right" valign="top"><a id="aa858318acd7f22d1f326b9473198e758"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>splice_after</b> (<a class="el" href="a05942.html">const_iterator</a> __pos, <a class="el" href="a05954.html">forward_list</a> &amp;__list) noexcept</td></tr>
<tr class="separator:aa858318acd7f22d1f326b9473198e758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e50d37869d4a598469d835dfcc3f011"><td class="memItemLeft" align="right" valign="top"><a id="a1e50d37869d4a598469d835dfcc3f011"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>splice_after</b> (<a class="el" href="a05942.html">const_iterator</a> __pos, <a class="el" href="a05954.html">forward_list</a> &amp;__list, <a class="el" href="a05942.html">const_iterator</a> __i) noexcept</td></tr>
<tr class="separator:a1e50d37869d4a598469d835dfcc3f011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c41eb7aabcd13c334d38bc68afe2cd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a3c41eb7aabcd13c334d38bc68afe2cd8">swap</a> (<a class="el" href="a05954.html">forward_list</a> &amp;__list) noexcept</td></tr>
<tr class="separator:a3c41eb7aabcd13c334d38bc68afe2cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83922c8c2f4ba5c7895749e6cd248c8"><td class="memItemLeft" align="right" valign="top">__remove_return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#aa83922c8c2f4ba5c7895749e6cd248c8">unique</a> ()</td></tr>
<tr class="separator:aa83922c8c2f4ba5c7895749e6cd248c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c10b7544adadf762ce0b1671faa42bd"><td class="memTemplParams" colspan="2">template&lt;typename _BinPred &gt; </td></tr>
<tr class="memitem:a0c10b7544adadf762ce0b1671faa42bd"><td class="memTemplItemLeft" align="right" valign="top">__remove_return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a05954.html#a0c10b7544adadf762ce0b1671faa42bd">unique</a> (_BinPred __binary_pred)</td></tr>
<tr class="separator:a0c10b7544adadf762ce0b1671faa42bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6b8e5bf9e8a2064f0ac9d8d709cbbb"><td class="memTemplParams" colspan="2"><a id="a3d6b8e5bf9e8a2064f0ac9d8d709cbbb"></a>
template&lt;typename _BinPred &gt; </td></tr>
<tr class="memitem:a3d6b8e5bf9e8a2064f0ac9d8d709cbbb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unique</b> (_BinPred __binary_pred) -&gt; __remove_return_type</td></tr>
<tr class="separator:a3d6b8e5bf9e8a2064f0ac9d8d709cbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9c1efa0c819d46d9d19f7fc363e14307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#a9c1efa0c819d46d9d19f7fc363e14307">splice_after</a> (<a class="el" href="a05942.html">const_iterator</a> __pos, <a class="el" href="a05954.html">forward_list</a> &amp;&amp;, <a class="el" href="a05942.html">const_iterator</a> __before, <a class="el" href="a05942.html">const_iterator</a> __last) noexcept</td></tr>
<tr class="separator:a9c1efa0c819d46d9d19f7fc363e14307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ba3ce45ccc225252b0a7b14e883dcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05954.html#ac9ba3ce45ccc225252b0a7b14e883dcc">splice_after</a> (<a class="el" href="a05942.html">const_iterator</a> __pos, <a class="el" href="a05954.html">forward_list</a> &amp;, <a class="el" href="a05942.html">const_iterator</a> __before, <a class="el" href="a05942.html">const_iterator</a> __last) noexcept</td></tr>
<tr class="separator:ac9ba3ce45ccc225252b0a7b14e883dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Tp, typename _Alloc = allocator&lt;_Tp&gt;&gt;<br />
class std::forward_list&lt; _Tp, _Alloc &gt;</h3>

<p>A standard container with linear time access to elements, and fixed time insertion/deletion at any point in the sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Type of element. </td></tr>
    <tr><td class="paramname">_Alloc</td><td>Allocator type, defaults to allocator&lt;_Tp&gt;.</td></tr>
  </table>
  </dd>
</dl>
<p>Meets the requirements of a <a href="tables.html#65">container</a>, a <a href="tables.html#67">sequence</a>, including the <a href="tables.html#68">optional sequence requirements</a> with the exception of <code>at</code> and <code>operator</code>[].</p>
<p>This is a <em>singly</em> <em>linked</em> list. Traversal up the list requires linear time, but adding and removing elements (or <em>nodes</em>) is done in constant time, regardless of where the change takes place. Unlike std::vector and std::deque, random-access iterators are not provided, so subscripting ( <code></code>[] ) access is not allowed. For algorithms which only need sequential access, this lack makes no difference.</p>
<p>Also unlike the other standard containers, std::forward_list provides specialized algorithms unique to linked lists, such as splicing, sorting, and in-place reversal. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00431">431</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2d179d6a061a4e6d8dcea244cdc29fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d179d6a061a4e6d8dcea244cdc29fe7">&#9670;&nbsp;</a></span>forward_list() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a05954.html">forward_list</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a forward_list with no elements. </p>

</div>
</div>
<a id="a4876e29ab044344ca726a36b6cdca01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4876e29ab044344ca726a36b6cdca01b">&#9670;&nbsp;</a></span>forward_list() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a05954.html">forward_list</a> </td>
          <td>(</td>
          <td class="paramtype">const _Alloc &amp;&#160;</td>
          <td class="paramname"><em>__al</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a forward_list with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__al</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00474">474</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a5db7e57854e789a4e93d7f12fbae8d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db7e57854e789a4e93d7f12fbae8d69">&#9670;&nbsp;</a></span>forward_list() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a05954.html">forward_list</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const __type_identity_t&lt; _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__al</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with allocator argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__list</td><td>Input list to copy. </td></tr>
    <tr><td class="paramname">__al</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00483">483</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">References <a class="el" href="a00419_source.html#l00732">std::forward_list&lt; _Tp, _Alloc &gt;::begin()</a>, and <a class="el" href="a00419_source.html#l00752">std::forward_list&lt; _Tp, _Alloc &gt;::end()</a>.</p>

</div>
</div>
<a id="aa34b172ec3558a231ee4193f98fd757d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34b172ec3558a231ee4193f98fd757d">&#9670;&nbsp;</a></span>forward_list() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a05954.html">forward_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const __type_identity_t&lt; _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__al</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with allocator argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__list</td><td>Input list to move. </td></tr>
    <tr><td class="paramname">__al</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00512">512</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a950f84e93e993ce756a016954c4322db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950f84e93e993ce756a016954c4322db">&#9670;&nbsp;</a></span>forward_list() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a05954.html">forward_list</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Alloc &amp;&#160;</td>
          <td class="paramname"><em>__al</em> = <code>_Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a forward_list with default constructed elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The number of elements to initially create. </td></tr>
    <tr><td class="paramname">__al</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates the forward_list with <em>__n</em> default constructed elements. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00528">528</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a81dc09fa341ed4c54da852f6a430bba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dc09fa341ed4c54da852f6a430bba2">&#9670;&nbsp;</a></span>forward_list() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a05954.html">forward_list</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Alloc &amp;&#160;</td>
          <td class="paramname"><em>__al</em> = <code>_Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a forward_list with copies of an exemplar element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The number of elements to initially create. </td></tr>
    <tr><td class="paramname">__value</td><td>An element to copy. </td></tr>
    <tr><td class="paramname">__al</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor fills the forward_list with <em>__n</em> copies of <em>__value</em>. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00541">541</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="ac9a366e3ba3ca40c479e0f33e664e6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a366e3ba3ca40c479e0f33e664e6e7">&#9670;&nbsp;</a></span>forward_list() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a05954.html">forward_list</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Alloc &amp;&#160;</td>
          <td class="paramname"><em>__al</em> = <code>_Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a forward_list from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__al</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a forward_list consisting of copies of the elements from [<em>__first</em>,<em>__last</em>). This is linear in N (where N is distance(<em>__first</em>,<em>__last</em>)). </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00558">558</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a642ecbf961b6a99a7deb77e676e71cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642ecbf961b6a99a7deb77e676e71cac">&#9670;&nbsp;</a></span>forward_list() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a05954.html">forward_list</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The forward_list copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__list</td><td>A forward_list of identical element and allocator types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00568">568</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">References <a class="el" href="a00419_source.html#l00732">std::forward_list&lt; _Tp, _Alloc &gt;::begin()</a>, and <a class="el" href="a00419_source.html#l00752">std::forward_list&lt; _Tp, _Alloc &gt;::end()</a>.</p>

</div>
</div>
<a id="ac57eaebb7af37579e166cb2c2b753f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57eaebb7af37579e166cb2c2b753f53">&#9670;&nbsp;</a></span>forward_list() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a05954.html">forward_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The forward_list move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__list</td><td>A forward_list of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>The newly-created forward_list contains the exact contents of the moved instance. The contents of the moved instance are a valid, but unspecified forward_list. </p>

</div>
</div>
<a id="a925933047508f0bd16df276c4f0261e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925933047508f0bd16df276c4f0261e4">&#9670;&nbsp;</a></span>forward_list() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a05954.html">forward_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">std::initializer_list</a>&lt; _Tp &gt;&#160;</td>
          <td class="paramname"><em>__il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Alloc &amp;&#160;</td>
          <td class="paramname"><em>__al</em> = <code>_Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a forward_list from an initializer_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__il</td><td>An initializer_list of value_type. </td></tr>
    <tr><td class="paramname">__al</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a forward_list consisting of copies of the elements in the initializer_list <em>__il</em>. This is linear in __il.size(). </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00592">592</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a30c16633a2af635de7b7646ab8c29e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c16633a2af635de7b7646ab8c29e46">&#9670;&nbsp;</a></span>~forward_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::~<a class="el" href="a05954.html">forward_list</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The forward_list dtor. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00600">600</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaf0bffb70955f72cf2972e70155e13d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0bffb70955f72cf2972e70155e13d2">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a range to a forward_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a forward_list with copies of the elements in the range [<em>__first</em>,<em>__last</em>).</p>
<p>Note that the assignment completely changes the forward_list and that the number of elements of the resulting forward_list is the same as the number of elements assigned. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00668">668</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00419_source.html#l00697">std::forward_list&lt; _Tp, _Alloc &gt;::assign()</a>, and <a class="el" href="a00419_source.html#l00647">std::forward_list&lt; _Tp, _Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a834314c2bf6e162dab99f07f1d6c551d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834314c2bf6e162dab99f07f1d6c551d">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a given value to a forward_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Number of elements to be assigned. </td></tr>
    <tr><td class="paramname">__val</td><td>Value to be assigned.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a forward_list with <em>__n</em> copies of the given value. Note that the assignment completely changes the forward_list, and that the resulting forward_list has __n elements. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00685">685</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="adcaa8789d2741f6b65603b41c8aba63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcaa8789d2741f6b65603b41c8aba63f">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">std::initializer_list</a>&lt; _Tp &gt;&#160;</td>
          <td class="paramname"><em>__il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an initializer_list to a forward_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__il</td><td>An initializer_list of value_type.</td></tr>
  </table>
  </dd>
</dl>
<p>Replace the contents of the forward_list with copies of the elements in the initializer_list <em>__il</em>. This is linear in il.size(). </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00697">697</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">References <a class="el" href="a00419_source.html#l00668">std::forward_list&lt; _Tp, _Alloc &gt;::assign()</a>.</p>

</div>
</div>
<a id="a1b8f8d9f8c5572304785f24529c297c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8f8d9f8c5572304785f24529c297c6">&#9670;&nbsp;</a></span>before_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05942.html">const_iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::before_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points before the first element in the forward_list. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00723">723</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a4becc964d2aa37c756215139094d8ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4becc964d2aa37c756215139094d8ff8">&#9670;&nbsp;</a></span>before_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05938.html">iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::before_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points before the first element in the forward_list. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00713">713</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00422_source.html#l00256">std::forward_list&lt; _Tp, _Alloc &gt;::insert_after()</a>.</p>

</div>
</div>
<a id="a8913be197ae32ed6898686dfa3f1bfdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8913be197ae32ed6898686dfa3f1bfdf">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05942.html">const_iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the forward_list. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00742">742</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a141f3a112d865e3125cb105b429c2a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141f3a112d865e3125cb105b429c2a63">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05938.html">iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points to the first element in the forward_list. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00732">732</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00419_source.html#l00483">std::forward_list&lt; _Tp, _Alloc &gt;::forward_list()</a>.</p>

</div>
</div>
<a id="a8e747964c0b29e83f50020110f4b1d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e747964c0b29e83f50020110f4b1d72">&#9670;&nbsp;</a></span>cbefore_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05942.html">const_iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::cbefore_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points before the first element in the forward_list. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00782">782</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00419_source.html#l00857">std::forward_list&lt; _Tp, _Alloc &gt;::emplace_front()</a>, and <a class="el" href="a00419_source.html#l00877">std::forward_list&lt; _Tp, _Alloc &gt;::push_front()</a>.</p>

</div>
</div>
<a id="ace31decae76d75133e08418f392a78b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace31decae76d75133e08418f392a78b3">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05942.html">const_iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the forward_list. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00772">772</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00419_source.html#l01494">std::operator&lt;()</a>, <a class="el" href="a00422_source.html#l00140">std::forward_list&lt; _Tp, _Alloc &gt;::operator=()</a>, and <a class="el" href="a00422_source.html#l00393">std::operator==()</a>.</p>

</div>
</div>
<a id="aaa651df81ec5161454becd5198407986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa651df81ec5161454becd5198407986">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05942.html">const_iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the forward_list. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00792">792</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00419_source.html#l01494">std::operator&lt;()</a>, <a class="el" href="a00422_source.html#l00140">std::forward_list&lt; _Tp, _Alloc &gt;::operator=()</a>, and <a class="el" href="a00422_source.html#l00393">std::operator==()</a>.</p>

</div>
</div>
<a id="aa88c1d40b71b3724ca63da3b66d4a5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88c1d40b71b3724ca63da3b66d4a5e0">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all the elements. </p>
<p>Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l01109">1109</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a5fd1e68be8454830cea449ad8114cf3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd1e68be8454830cea449ad8114cf3d">&#9670;&nbsp;</a></span>emplace_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05938.html">iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::emplace_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs object in forward_list after the specified iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>A const_iterator into the forward_list. </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert an object of type T constructed with T(std::forward&lt;Args&gt;(args)...) after the specified location. Due to the nature of a forward_list this operation can be done in constant time, and does not invalidate iterators and references. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00918">918</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a950aacf736d4f143794cacefbd742a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950aacf736d4f143794cacefbd742a7a">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs object in forward_list at the front of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__args</td><td>Arguments.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will insert an object of type Tp constructed with Tp(std::forward&lt;Args&gt;(args)...) at the front of the list Due to the nature of a forward_list this operation can be done in constant time, and does not invalidate iterators and references. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00857">857</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">References <a class="el" href="a00419_source.html#l00782">std::forward_list&lt; _Tp, _Alloc &gt;::cbefore_begin()</a>, and <a class="el" href="a00419_source.html#l00820">std::forward_list&lt; _Tp, _Alloc &gt;::front()</a>.</p>

</div>
</div>
<a id="ab0a3479429315d1735f3d6b15817b01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a3479429315d1735f3d6b15817b01e">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the forward_list is empty. (Thus begin() would equal end().) </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00801">801</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00422_source.html#l00271">std::forward_list&lt; _Tp, _Alloc &gt;::insert_after()</a>.</p>

</div>
</div>
<a id="a9a320037c76fc8f0e6f60784dcec1383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a320037c76fc8f0e6f60784dcec1383">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05942.html">const_iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only iterator that points one past the last element in the forward_list. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00762">762</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a7f64feff678dd8cb85d35bd9b08fde54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f64feff678dd8cb85d35bd9b08fde54">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05938.html">iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points one past the last element in the forward_list. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00752">752</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00419_source.html#l00483">std::forward_list&lt; _Tp, _Alloc &gt;::forward_list()</a>, and <a class="el" href="a00422_source.html#l00256">std::forward_list&lt; _Tp, _Alloc &gt;::insert_after()</a>.</p>

</div>
</div>
<a id="a369164fbcb598a49bbd7297eb6f2c5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369164fbcb598a49bbd7297eb6f2c5b0">&#9670;&nbsp;</a></span>erase_after() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05938.html">iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::erase_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element pointed to by the iterator following <code>pos</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>Iterator pointing before element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element following the one that was erased, or end() if no such element exists.</dd></dl>
<p>This function will erase the element at the given position and thus shorten the forward_list by one.</p>
<p>Due to the nature of a forward_list this operation can be done in constant time, and only invalidates iterators/references to the element being removed. The user is also cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l01021">1021</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="aa779e251eac11a2d84fa9a2b65921bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa779e251eac11a2d84fa9a2b65921bae">&#9670;&nbsp;</a></span>erase_after() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05938.html">iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::erase_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>Iterator pointing before the first element to be erased. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to one past the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>@ __last.</dd></dl>
<p>This function will erase the elements in the range <em></em>(__pos,__last) and shorten the forward_list accordingly.</p>
<p>This operation is linear time in the size of the range and only invalidates iterators/references to the element being removed. The user is also cautioned that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l01044">1044</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="aa2daca181da8d9a22ecc19e4a7364b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2daca181da8d9a22ecc19e4a7364b1f">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reference to the data at the first element of the forward_list. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00820">820</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00419_source.html#l00857">std::forward_list&lt; _Tp, _Alloc &gt;::emplace_front()</a>.</p>

</div>
</div>
<a id="a40c8314a3fb6d46884588bcab67111b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c8314a3fb6d46884588bcab67111b5">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reference to the data at the first element of the forward_list. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00832">832</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="ab66a5f239cf5fe9431700b756e711b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66a5f239cf5fe9431700b756e711b4a">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the memory allocation object. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00702">702</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a03cc027e568ad94dbbbc25da7d485fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cc027e568ad94dbbbc25da7d485fe7">&#9670;&nbsp;</a></span>insert_after() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc &gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a05938.html">iterator</a> forward_list::insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a range into the forward_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>An iterator into the forward_list. </td></tr>
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the last inserted element or <em>__pos</em> if <em>__first</em> == <em>__last</em>.</dd></dl>
<p>This function will insert copies of the data in the range [<em>__first</em>,<em>__last</em>) into the forward_list after the location specified by <em>__pos</em>.</p>
<p>This operation is linear in the number of elements inserted and does not invalidate iterators and references. </p>

<p class="definition">Definition at line <a class="el" href="a00422_source.html#l00270">270</a> of file <a class="el" href="a00422_source.html">forward_list.tcc</a>.</p>

<p class="reference">References <a class="el" href="a00419_source.html#l00713">std::forward_list&lt; _Tp, _Alloc &gt;::before_begin()</a>, <a class="el" href="a00419_source.html#l00801">std::forward_list&lt; _Tp, _Alloc &gt;::empty()</a>, and <a class="el" href="a00419_source.html#l00752">std::forward_list&lt; _Tp, _Alloc &gt;::end()</a>.</p>

</div>
</div>
<a id="a6f8e1063932912fb3e245b7c8116ed1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8e1063932912fb3e245b7c8116ed1f">&#9670;&nbsp;</a></span>insert_after() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05938.html">iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts given value into forward_list after specified iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>An iterator into the forward_list. </td></tr>
    <tr><td class="paramname">__val</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert a copy of the given value after the specified location. Due to the nature of a forward_list this operation can be done in constant time, and does not invalidate iterators and references. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00935">935</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00419_source.html#l01000">std::forward_list&lt; _Tp, _Alloc &gt;::insert_after()</a>.</p>

</div>
</div>
<a id="a4921af283fd230d563266ca0ce14a455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4921af283fd230d563266ca0ce14a455">&#9670;&nbsp;</a></span>insert_after() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a05938.html">iterator</a> forward_list::insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a number of copies of given data into the forward_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>An iterator into the forward_list. </td></tr>
    <tr><td class="paramname">__n</td><td>Number of elements to be inserted. </td></tr>
    <tr><td class="paramname">__val</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the last inserted copy of <em>val</em> or <em>pos</em> if <em>n</em> == 0.</dd></dl>
<p>This function will insert a specified number of copies of the given data after the location specified by <em>pos</em>.</p>
<p>This operation is linear in the number of elements inserted and does not invalidate iterators and references. </p>

<p class="definition">Definition at line <a class="el" href="a00422_source.html#l00255">255</a> of file <a class="el" href="a00422_source.html">forward_list.tcc</a>.</p>

<p class="reference">References <a class="el" href="a00419_source.html#l00713">std::forward_list&lt; _Tp, _Alloc &gt;::before_begin()</a>, and <a class="el" href="a00419_source.html#l00752">std::forward_list&lt; _Tp, _Alloc &gt;::end()</a>.</p>

</div>
</div>
<a id="a9739cbb5af18ac9976288f6c9c072bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9739cbb5af18ac9976288f6c9c072bb0">&#9670;&nbsp;</a></span>insert_after() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05938.html">iterator</a> <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01878.html">std::initializer_list</a>&lt; _Tp &gt;&#160;</td>
          <td class="paramname"><em>__il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the contents of an initializer_list into forward_list after the specified iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>An iterator into the forward_list. </td></tr>
    <tr><td class="paramname">__il</td><td>An initializer_list of value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the last inserted element or <em>__pos</em> if <em>__il</em> is empty.</dd></dl>
<p>This function will insert copies of the data in the initializer_list <em>__il</em> into the forward_list before the location specified by <em>__pos</em>.</p>
<p>This operation is linear in the number of elements inserted and does not invalidate iterators and references. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l01000">1000</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">References <a class="el" href="a00419_source.html#l00935">std::forward_list&lt; _Tp, _Alloc &gt;::insert_after()</a>.</p>

</div>
</div>
<a id="ae19c74808b1bc8e53bdc229fd3d389fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19c74808b1bc8e53bdc229fd3d389fa">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the largest possible number of elements of forward_list. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00809">809</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">References <a class="el" href="a19243_source.html#l00389">__gnu_cxx::__alloc_traits&lt; _Alloc, typename &gt;::max_size()</a>.</p>

</div>
</div>
<a id="a4794e46af448c443019e9b36640744ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4794e46af448c443019e9b36640744ab">&#9670;&nbsp;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge sorted lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__list</td><td>Sorted list to merge.</td></tr>
  </table>
  </dd>
</dl>
<p>Assumes that both <em>list</em> and this list are sorted according to operator&lt;(). Merges elements of <em>__list</em> into this list in sorted order, leaving <em>__list</em> empty when complete. Elements in this list precede elements in <em>__list</em> that are equal. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l01265">1265</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="a0de7b075b73cc0a843447ad75cba4b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de7b075b73cc0a843447ad75cba4b87">&#9670;&nbsp;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc &gt; </div>
<div class="memtemplate">
template&lt;typename _Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void forward_list::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Comp&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge sorted lists according to comparison function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__list</td><td>Sorted list to merge. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison function defining sort order.</td></tr>
  </table>
  </dd>
</dl>
<p>Assumes that both <em>__list</em> and this list are sorted according to comp. Merges elements of <em>__list</em> into this list in sorted order, leaving <em>__list</em> empty when complete. Elements in this list precede elements in <em>__list</em> that are equivalent according to comp(). </p>

<p class="definition">Definition at line <a class="el" href="a00422_source.html#l00367">367</a> of file <a class="el" href="a00422_source.html">forward_list.tcc</a>.</p>

</div>
</div>
<a id="a78c1273fb53228cab655addd77f9cd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c1273fb53228cab655addd77f9cd25">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp; forward_list::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The forward_list assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__list</td><td>A forward_list of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>All the elements of <em>__list</em> are copied.</p>
<p>Whether the allocator is copied depends on the allocator traits. </p>

<p class="definition">Definition at line <a class="el" href="a00422_source.html#l00139">139</a> of file <a class="el" href="a00422_source.html">forward_list.tcc</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00049">std::__addressof()</a>, <a class="el" href="a00419_source.html#l00772">std::forward_list&lt; _Tp, _Alloc &gt;::cbegin()</a>, and <a class="el" href="a00419_source.html#l00792">std::forward_list&lt; _Tp, _Alloc &gt;::cend()</a>.</p>

</div>
</div>
<a id="aaedecd0634ab8c057cca203778ea6cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedecd0634ab8c057cca203778ea6cfa">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">forward_list</a>&amp; <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The forward_list move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__list</td><td>A forward_list of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>The contents of <em>__list</em> are moved into this forward_list (without copying, if the allocators permit it).</p>
<p>Afterwards <em>__list</em> is a valid, but unspecified forward_list</p>
<p>Whether the allocator is moved depends on the allocator traits. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00628">628</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="a6b8dfcf0c3aad308699e909186c39f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8dfcf0c3aad308699e909186c39f2b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05954.html">forward_list</a>&amp; <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">std::initializer_list</a>&lt; _Tp &gt;&#160;</td>
          <td class="paramname"><em>__il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The forward_list initializer list assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__il</td><td>An initializer_list of value_type.</td></tr>
  </table>
  </dd>
</dl>
<p>Replace the contents of the forward_list with copies of the elements in the initializer_list <em>__il</em>. This is linear in __il.size(). </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00647">647</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">References <a class="el" href="a00419_source.html#l00668">std::forward_list&lt; _Tp, _Alloc &gt;::assign()</a>.</p>

</div>
</div>
<a id="ace75c01c591425341e21b6404e7f9e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace75c01c591425341e21b6404e7f9e90">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes first element. </p>
<p>This is a typical stack operation. It shrinks the forward_list by one. Due to the nature of a forward_list this operation can be done in constant time, and only invalidates iterators/references to the element being removed.</p>
<p>Note that no data is returned, and if the first element's data is needed, it should be retrieved before pop_front() is called. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00900">900</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="ac2d708075d40071265f0a376591ba1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d708075d40071265f0a376591ba1d7">&#9670;&nbsp;</a></span>push_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the front of the forward_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__val</td><td>Data to be added.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a typical stack operation. The function creates an element at the front of the forward_list and assigns the given data to it. Due to the nature of a forward_list this operation can be done in constant time, and does not invalidate iterators and references. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l00877">877</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">References <a class="el" href="a00419_source.html#l00782">std::forward_list&lt; _Tp, _Alloc &gt;::cbefore_begin()</a>.</p>

</div>
</div>
<a id="aa9b3162769904b5c710868fa13e9b8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b3162769904b5c710868fa13e9b8b9">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto forward_list::remove </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements equal to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__val</td><td>The value to remove.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes every element in the list equal to <em>__val</em>. Remaining elements stay in list order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00422_source.html#l00289">289</a> of file <a class="el" href="a00422_source.html">forward_list.tcc</a>.</p>

</div>
</div>
<a id="a7c7f79f92d9199ce7245925b27621304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7f79f92d9199ce7245925b27621304">&#9670;&nbsp;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__remove_return_type <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::remove_if </td>
          <td>(</td>
          <td class="paramtype">_Pred&#160;</td>
          <td class="paramname"><em>__pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements satisfying a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pred</td><td>Unary predicate function or object.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes every element in the list for which the predicate returns true. Remaining elements stay in list order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<a id="a73ffca07b591237200b852caf7040057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ffca07b591237200b852caf7040057">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void forward_list::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the forward_list to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__sz</td><td>Number of elements the forward_list should contain.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will resize the forward_list to the specified number of elements. If the number is smaller than the forward_list's current number of elements the forward_list is truncated, otherwise the forward_list is extended and the new elements are default constructed. </p>

<p class="definition">Definition at line <a class="el" href="a00422_source.html#l00181">181</a> of file <a class="el" href="a00422_source.html">forward_list.tcc</a>.</p>

<p class="reference">References <a class="el" href="a00035_source.html#l00101">std::initializer_list&lt; _E &gt;::end()</a>.</p>

</div>
</div>
<a id="abfb248e17d0392a8caf5c46683102332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb248e17d0392a8caf5c46683102332">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void forward_list::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the forward_list to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__sz</td><td>Number of elements the forward_list should contain. </td></tr>
    <tr><td class="paramname">__val</td><td>Data with which new elements should be populated.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will resize the forward_list to the specified number of elements. If the number is smaller than the forward_list's current number of elements the forward_list is truncated, otherwise the forward_list is extended and new elements are populated with given data. </p>

<p class="definition">Definition at line <a class="el" href="a00422_source.html#l00200">200</a> of file <a class="el" href="a00422_source.html">forward_list.tcc</a>.</p>

<p class="reference">References <a class="el" href="a00035_source.html#l00101">std::initializer_list&lt; _E &gt;::end()</a>.</p>

</div>
</div>
<a id="a2ab1413dfa1c6858634407a44504a368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab1413dfa1c6858634407a44504a368">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse the elements in list. </p>
<p>Reverse the order of elements in the list in linear time. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l01318">1318</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a4bb37711f3350692a1246d7781967ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb37711f3350692a1246d7781967ea6">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the elements of the list. </p>
<p>Sorts the elements of this list in NlogN time. Equivalent elements remain in list order. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l01299">1299</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a3f59eaf1f58f480eafa906d68d408682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f59eaf1f58f480eafa906d68d408682">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , class _Alloc &gt; </div>
<div class="memtemplate">
template&lt;typename _Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void forward_list::sort </td>
          <td>(</td>
          <td class="paramtype">_Comp&#160;</td>
          <td class="paramname"><em>__comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the forward_list using a comparison function. </p>
<p>Sorts the elements of this list in NlogN time. Equivalent elements remain in list order. </p>

<p class="definition">Definition at line <a class="el" href="a00422_source.html#l00416">416</a> of file <a class="el" href="a00422_source.html">forward_list.tcc</a>.</p>

</div>
</div>
<a id="a9c1efa0c819d46d9d19f7fc363e14307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1efa0c819d46d9d19f7fc363e14307">&#9670;&nbsp;</a></span>splice_after() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert range from another forward_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>Iterator referencing the element to insert after. </td></tr>
    <tr><td class="paramname">__list</td><td>Source list. </td></tr>
    <tr><td class="paramname">__before</td><td>Iterator referencing before the start of range in list. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator referencing the end of range in list.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes elements in the range (__before,__last) and inserts them after <em>__pos</em> in constant time.</p>
<p>Undefined if <em>__pos</em> is in (__before,__last). </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l01170">1170</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a8918bd7e48f28df3b891edfc246556d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8918bd7e48f28df3b891edfc246556d0">&#9670;&nbsp;</a></span>splice_after() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert contents of another forward_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>Iterator referencing the element to insert after. </td></tr>
    <tr><td class="paramname">__list</td><td>Source list.</td></tr>
  </table>
  </dd>
</dl>
<p>The elements of <em>list</em> are inserted in constant time after the element referenced by <em>pos</em>. <em>list</em> becomes an empty list.</p>
<p>Requires this != <em>x</em>. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l01126">1126</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="aa3a2a989959206263a683014f575cdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a2a989959206263a683014f575cdc3">&#9670;&nbsp;</a></span>splice_after() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void forward_list::splice_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert element from another forward_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>Iterator referencing the element to insert after. </td></tr>
    <tr><td class="paramname">__list</td><td>Source list. </td></tr>
    <tr><td class="paramname">__i</td><td>Iterator referencing the element before the element to move.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes the element in list <em>list</em> referenced by <em>i</em> and inserts it into the current list after <em>pos</em>. </p>

<p class="definition">Definition at line <a class="el" href="a00422_source.html#l00238">238</a> of file <a class="el" href="a00422_source.html">forward_list.tcc</a>.</p>

</div>
</div>
<a id="ac9ba3ce45ccc225252b0a7b14e883dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ba3ce45ccc225252b0a7b14e883dcc">&#9670;&nbsp;</a></span>splice_after() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05942.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert range from another forward_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>Iterator referencing the element to insert after. </td></tr>
    <tr><td class="paramname">__list</td><td>Source list. </td></tr>
    <tr><td class="paramname">__before</td><td>Iterator referencing before the start of range in list. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator referencing the end of range in list.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes elements in the range (__before,__last) and inserts them after <em>__pos</em> in constant time.</p>
<p>Undefined if <em>__pos</em> is in (__before,__last). </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l01175">1175</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a3c41eb7aabcd13c334d38bc68afe2cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c41eb7aabcd13c334d38bc68afe2cd8">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05954.html">forward_list</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps data with another forward_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__list</td><td>A forward_list of the same element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>This exchanges the elements between two lists in constant time. Note that the global std::swap() function is specialized such that std::swap(l1,l2) will feed to this function.</p>
<p>Whether the allocators are swapped depends on the allocator traits. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l01063">1063</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

<p class="reference">References <a class="el" href="a00047_source.html#l00429">std::swap()</a>.</p>

</div>
</div>
<a id="aa83922c8c2f4ba5c7895749e6cd248c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83922c8c2f4ba5c7895749e6cd248c8">&#9670;&nbsp;</a></span>unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__remove_return_type <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove consecutive duplicate elements. </p>
<p>For each consecutive set of elements with the same value, remove all but the first one. Remaining elements stay in list order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00419_source.html#l01234">1234</a> of file <a class="el" href="a00419_source.html">forward_list.h</a>.</p>

</div>
</div>
<a id="a0c10b7544adadf762ce0b1671faa42bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c10b7544adadf762ce0b1671faa42bd">&#9670;&nbsp;</a></span>unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _BinPred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__remove_return_type <a class="el" href="a05954.html">std::forward_list</a>&lt; _Tp, _Alloc &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">_BinPred&#160;</td>
          <td class="paramname"><em>__binary_pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove consecutive elements satisfying a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__binary_pred</td><td>Binary predicate function or object.</td></tr>
  </table>
  </dd>
</dl>
<p>For each consecutive set of elements [first,last) that satisfy predicate(first,i) where i is an iterator in [first,last), remove all but the first one. Remaining elements stay in list order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00419_source.html">forward_list.h</a></li>
<li><a class="el" href="a00422_source.html">forward_list.tcc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a01655.html">std</a></li><li class="navelem"><a class="el" href="a05954.html">forward_list</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
