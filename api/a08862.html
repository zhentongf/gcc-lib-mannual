<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstdc++: std::vector&lt; _Tp, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a08862.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a08859.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">std::vector&lt; _Tp, _Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for std::vector&lt; _Tp, _Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a08861.svg" width="150" height="150"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af6e9591d666d2751689d46b67ebe1054"><td class="memItemLeft" align="right" valign="top"><a id="af6e9591d666d2751689d46b67ebe1054"></a>
typedef _Alloc&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:af6e9591d666d2751689d46b67ebe1054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e57b89b9260db15b3b3c0c63549876"><td class="memItemLeft" align="right" valign="top"><a id="ad1e57b89b9260db15b3b3c0c63549876"></a>
typedef __gnu_cxx::__normal_iterator&lt; const_pointer, <a class="el" href="a08862.html">vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:ad1e57b89b9260db15b3b3c0c63549876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500eb907d83d64fecd35eb684ac458d3"><td class="memItemLeft" align="right" valign="top"><a id="a500eb907d83d64fecd35eb684ac458d3"></a>
typedef _Alloc_traits::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a500eb907d83d64fecd35eb684ac458d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad33e7c8765b56566c9b7729b2873373"><td class="memItemLeft" align="right" valign="top"><a id="aad33e7c8765b56566c9b7729b2873373"></a>
typedef _Alloc_traits::const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:aad33e7c8765b56566c9b7729b2873373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead130cd36f83bf0c8ff5520c5cf9e75"><td class="memItemLeft" align="right" valign="top"><a id="aead130cd36f83bf0c8ff5520c5cf9e75"></a>
typedef <a class="el" href="a08518.html">std::reverse_iterator</a>&lt; const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:aead130cd36f83bf0c8ff5520c5cf9e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416c92b8ab1a276a90da34fed46f8fea"><td class="memItemLeft" align="right" valign="top"><a id="a416c92b8ab1a276a90da34fed46f8fea"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a416c92b8ab1a276a90da34fed46f8fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6115ff023e7a32c02012726db8104cbe"><td class="memItemLeft" align="right" valign="top"><a id="a6115ff023e7a32c02012726db8104cbe"></a>
typedef __gnu_cxx::__normal_iterator&lt; pointer, <a class="el" href="a08862.html">vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a6115ff023e7a32c02012726db8104cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac969adc9cac1f455b7449aa114ad6aa0"><td class="memItemLeft" align="right" valign="top"><a id="ac969adc9cac1f455b7449aa114ad6aa0"></a>
typedef _Base::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:ac969adc9cac1f455b7449aa114ad6aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08649ce757452ffcd50400c756539cb"><td class="memItemLeft" align="right" valign="top"><a id="ad08649ce757452ffcd50400c756539cb"></a>
typedef _Alloc_traits::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:ad08649ce757452ffcd50400c756539cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872c5273d5967f4a3ab4e3ba7bdfd5f8"><td class="memItemLeft" align="right" valign="top"><a id="a872c5273d5967f4a3ab4e3ba7bdfd5f8"></a>
typedef <a class="el" href="a08518.html">std::reverse_iterator</a>&lt; iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a872c5273d5967f4a3ab4e3ba7bdfd5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c431c4aa8cb312a241413a5b669c853"><td class="memItemLeft" align="right" valign="top"><a id="a0c431c4aa8cb312a241413a5b669c853"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a0c431c4aa8cb312a241413a5b669c853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e0c2e27828d3d892b9fa50e45e1d93"><td class="memItemLeft" align="right" valign="top"><a id="a44e0c2e27828d3d892b9fa50e45e1d93"></a>
typedef _Tp&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a44e0c2e27828d3d892b9fa50e45e1d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1629a99cef9608b6d37cb67ce1e5c058"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a1629a99cef9608b6d37cb67ce1e5c058">vector</a> ()=default</td></tr>
<tr class="separator:a1629a99cef9608b6d37cb67ce1e5c058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5e214249faa99bbc16b98ab7336ab4"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </td></tr>
<tr class="memitem:aab5e214249faa99bbc16b98ab7336ab4"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08862.html#aab5e214249faa99bbc16b98ab7336ab4">vector</a> (_InputIterator __first, _InputIterator __last, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:aab5e214249faa99bbc16b98ab7336ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebcef120d19a26b2b2ba0dfdceb2ad7"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a8ebcef120d19a26b2b2ba0dfdceb2ad7">vector</a> (const allocator_type &amp;__a) noexcept</td></tr>
<tr class="separator:a8ebcef120d19a26b2b2ba0dfdceb2ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b6b19021c96e2c33f21034a4532ff0"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a15b6b19021c96e2c33f21034a4532ff0">vector</a> (const <a class="el" href="a08862.html">vector</a> &amp;__x)</td></tr>
<tr class="separator:a15b6b19021c96e2c33f21034a4532ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8313a199bf28ee8387348dede2f6d4"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#aba8313a199bf28ee8387348dede2f6d4">vector</a> (const <a class="el" href="a08862.html">vector</a> &amp;__x, const __type_identity_t&lt; allocator_type &gt; &amp;__a)</td></tr>
<tr class="separator:aba8313a199bf28ee8387348dede2f6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2717e4081a34b11645c512a5781ebc"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#aac2717e4081a34b11645c512a5781ebc">vector</a> (<a class="el" href="a01878.html">initializer_list</a>&lt; value_type &gt; __l, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:aac2717e4081a34b11645c512a5781ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46234923032a08ecb8800b880bb2975e"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a46234923032a08ecb8800b880bb2975e">vector</a> (size_type __n, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:a46234923032a08ecb8800b880bb2975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24d71d1f19e3161ffdc5c41b0c594ae"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#ae24d71d1f19e3161ffdc5c41b0c594ae">vector</a> (size_type __n, const value_type &amp;__value, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:ae24d71d1f19e3161ffdc5c41b0c594ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab046bf21cbed50d0847f467a3b6d463a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#ab046bf21cbed50d0847f467a3b6d463a">vector</a> (<a class="el" href="a08862.html">vector</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:ab046bf21cbed50d0847f467a3b6d463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7bf79e9024376071a3e87bb7bf6c12"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a3f7bf79e9024376071a3e87bb7bf6c12">vector</a> (<a class="el" href="a08862.html">vector</a> &amp;&amp;__rv, const __type_identity_t&lt; allocator_type &gt; &amp;__m) noexcept(noexcept(<a class="el" href="a08862.html">vector</a>(<a class="el" href="a01588.html#ga2b4e53aac9e7c7024ad03eaf21c57471">std::declval</a>&lt; <a class="el" href="a08862.html">vector</a> &amp;&amp; &gt;(), <a class="el" href="a01588.html#ga2b4e53aac9e7c7024ad03eaf21c57471">std::declval</a>&lt; const allocator_type &amp; &gt;(), <a class="el" href="a01588.html#ga2b4e53aac9e7c7024ad03eaf21c57471">std::declval</a>&lt; typename <a class="el" href="a04978.html#afae6957b1a6d68084b2b6114dff01ae8">_Alloc_traits::is_always_equal</a> &gt;())))</td></tr>
<tr class="separator:a3f7bf79e9024376071a3e87bb7bf6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f5f67acef67281a696cdc88e27fe6f"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a27f5f67acef67281a696cdc88e27fe6f">~vector</a> () noexcept</td></tr>
<tr class="separator:a27f5f67acef67281a696cdc88e27fe6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017636de3585744269645542c72299cc"><td class="memTemplParams" colspan="2"><a id="a017636de3585744269645542c72299cc"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a017636de3585744269645542c72299cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_emplace_aux</b> (const_iterator __position, _Args &amp;&amp;... __args) -&gt; iterator</td></tr>
<tr class="separator:a017636de3585744269645542c72299cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c4ec50d0c01b54a99483e9a2e62404"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </td></tr>
<tr class="memitem:a29c4ec50d0c01b54a99483e9a2e62404"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08862.html#a29c4ec50d0c01b54a99483e9a2e62404">assign</a> (_InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:a29c4ec50d0c01b54a99483e9a2e62404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2457f1d9d156b6683a57944fa61084"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#abb2457f1d9d156b6683a57944fa61084">assign</a> (<a class="el" href="a01878.html">initializer_list</a>&lt; value_type &gt; __l)</td></tr>
<tr class="separator:abb2457f1d9d156b6683a57944fa61084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3100ced0975b432bed6e7b793f056f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a2d3100ced0975b432bed6e7b793f056f">assign</a> (size_type __n, const value_type &amp;__val)</td></tr>
<tr class="separator:a2d3100ced0975b432bed6e7b793f056f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f5788cba9bc9c69b07420bc31dcf2e"><td class="memItemLeft" align="right" valign="top">constexpr reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a66f5788cba9bc9c69b07420bc31dcf2e">at</a> (size_type __n)</td></tr>
<tr class="separator:a66f5788cba9bc9c69b07420bc31dcf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82d70daf901ebe75d471bb6d1eefb67"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#aa82d70daf901ebe75d471bb6d1eefb67">at</a> (size_type __n) const</td></tr>
<tr class="separator:aa82d70daf901ebe75d471bb6d1eefb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6548c1e0ab1200834070170bd76f07cc"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a6548c1e0ab1200834070170bd76f07cc">back</a> () const noexcept</td></tr>
<tr class="separator:a6548c1e0ab1200834070170bd76f07cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef70c7e68b53c133dd35cd871fbcfb19"><td class="memItemLeft" align="right" valign="top">constexpr reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#aef70c7e68b53c133dd35cd871fbcfb19">back</a> () noexcept</td></tr>
<tr class="separator:aef70c7e68b53c133dd35cd871fbcfb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b3247394c6a5110b39b89dc8a310bd"><td class="memItemLeft" align="right" valign="top">constexpr const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a28b3247394c6a5110b39b89dc8a310bd">begin</a> () const noexcept</td></tr>
<tr class="separator:a28b3247394c6a5110b39b89dc8a310bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa4b1c4fd03874d5e43877c3e466ee8"><td class="memItemLeft" align="right" valign="top">constexpr iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a1fa4b1c4fd03874d5e43877c3e466ee8">begin</a> () noexcept</td></tr>
<tr class="separator:a1fa4b1c4fd03874d5e43877c3e466ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22049143588a50ab6b1fc555e689b9c7"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a22049143588a50ab6b1fc555e689b9c7">capacity</a> () const noexcept</td></tr>
<tr class="separator:a22049143588a50ab6b1fc555e689b9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa81688ee8ea9b9d787a38463c631940"><td class="memItemLeft" align="right" valign="top">constexpr const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#aaa81688ee8ea9b9d787a38463c631940">cbegin</a> () const noexcept</td></tr>
<tr class="separator:aaa81688ee8ea9b9d787a38463c631940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b1709557966323d397a8d5ef658415"><td class="memItemLeft" align="right" valign="top">constexpr const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#af8b1709557966323d397a8d5ef658415">cend</a> () const noexcept</td></tr>
<tr class="separator:af8b1709557966323d397a8d5ef658415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c08a435f4bdcba3ba3e74e50a6d23c"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#ab9c08a435f4bdcba3ba3e74e50a6d23c">clear</a> () noexcept</td></tr>
<tr class="separator:ab9c08a435f4bdcba3ba3e74e50a6d23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8c92caa3ad719523d4cef67aa46518"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="a08518.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a9a8c92caa3ad719523d4cef67aa46518">crbegin</a> () const noexcept</td></tr>
<tr class="separator:a9a8c92caa3ad719523d4cef67aa46518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e43d049d329f67ffd424d61c4ecb5f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="a08518.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#af4e43d049d329f67ffd424d61c4ecb5f">crend</a> () const noexcept</td></tr>
<tr class="separator:af4e43d049d329f67ffd424d61c4ecb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b64dc7d92425ec5f1e79915cc1588da"><td class="memItemLeft" align="right" valign="top"><a id="a6b64dc7d92425ec5f1e79915cc1588da"></a>
constexpr const _Tp *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const noexcept</td></tr>
<tr class="separator:a6b64dc7d92425ec5f1e79915cc1588da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e845611f07919062c843fa5ab364ab1"><td class="memItemLeft" align="right" valign="top">constexpr _Tp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a4e845611f07919062c843fa5ab364ab1">data</a> () noexcept</td></tr>
<tr class="separator:a4e845611f07919062c843fa5ab364ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162bbd57ea9dad26ccf3aae78e98c4ba"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a162bbd57ea9dad26ccf3aae78e98c4ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08862.html#a162bbd57ea9dad26ccf3aae78e98c4ba">emplace</a> (const_iterator __position, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a162bbd57ea9dad26ccf3aae78e98c4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66073f45719986dc2c34f6600c7b6542"><td class="memTemplParams" colspan="2"><a id="a66073f45719986dc2c34f6600c7b6542"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a66073f45719986dc2c34f6600c7b6542"><td class="memTemplItemLeft" align="right" valign="top">constexpr reference&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_back</b> (_Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a66073f45719986dc2c34f6600c7b6542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929d5baba01bee31ac909918be338655"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a929d5baba01bee31ac909918be338655">empty</a> () const noexcept</td></tr>
<tr class="separator:a929d5baba01bee31ac909918be338655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5f353afd4e55321e07e5516faea08c"><td class="memItemLeft" align="right" valign="top">constexpr const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#aad5f353afd4e55321e07e5516faea08c">end</a> () const noexcept</td></tr>
<tr class="separator:aad5f353afd4e55321e07e5516faea08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6603dd1f0d71126f4429596abf0ca4"><td class="memItemLeft" align="right" valign="top">constexpr iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a0e6603dd1f0d71126f4429596abf0ca4">end</a> () noexcept</td></tr>
<tr class="separator:a0e6603dd1f0d71126f4429596abf0ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3891eac8d375a8f1f8c1817ee40e3006"><td class="memItemLeft" align="right" valign="top">constexpr iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a3891eac8d375a8f1f8c1817ee40e3006">erase</a> (const_iterator __first, const_iterator __last)</td></tr>
<tr class="separator:a3891eac8d375a8f1f8c1817ee40e3006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fc09b351a61fabdffebcb22012a0d8"><td class="memItemLeft" align="right" valign="top">constexpr iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a91fc09b351a61fabdffebcb22012a0d8">erase</a> (const_iterator __position)</td></tr>
<tr class="separator:a91fc09b351a61fabdffebcb22012a0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4761caae3c1584f90278198de30cb1d7"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a4761caae3c1584f90278198de30cb1d7">front</a> () const noexcept</td></tr>
<tr class="separator:a4761caae3c1584f90278198de30cb1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0ffd29fde812666b492d05848b7414"><td class="memItemLeft" align="right" valign="top">constexpr reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a7e0ffd29fde812666b492d05848b7414">front</a> () noexcept</td></tr>
<tr class="separator:a7e0ffd29fde812666b492d05848b7414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e13307a83139885af1475b01cfd4a8"><td class="memItemLeft" align="right" valign="top">constexpr allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#ac2e13307a83139885af1475b01cfd4a8">get_allocator</a> () const noexcept</td></tr>
<tr class="separator:ac2e13307a83139885af1475b01cfd4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab547528b49a234720493fce03da17d45"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </td></tr>
<tr class="memitem:ab547528b49a234720493fce03da17d45"><td class="memTemplItemLeft" align="right" valign="top">constexpr iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08862.html#ab547528b49a234720493fce03da17d45">insert</a> (const_iterator __position, _InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:ab547528b49a234720493fce03da17d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022eaccfa36211f2ea979703414dd357"><td class="memItemLeft" align="right" valign="top">constexpr iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a022eaccfa36211f2ea979703414dd357">insert</a> (const_iterator __position, const value_type &amp;__x)</td></tr>
<tr class="separator:a022eaccfa36211f2ea979703414dd357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2505d5c509abc7eab6d9fedbd8d68c41"><td class="memItemLeft" align="right" valign="top">constexpr iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a2505d5c509abc7eab6d9fedbd8d68c41">insert</a> (const_iterator __position, <a class="el" href="a01878.html">initializer_list</a>&lt; value_type &gt; __l)</td></tr>
<tr class="separator:a2505d5c509abc7eab6d9fedbd8d68c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8711eff0025743446d83b5bf9ac1d3eb"><td class="memItemLeft" align="right" valign="top">constexpr iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a8711eff0025743446d83b5bf9ac1d3eb">insert</a> (const_iterator __position, size_type __n, const value_type &amp;__x)</td></tr>
<tr class="separator:a8711eff0025743446d83b5bf9ac1d3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c15020e334c661e6358e62c6b33943d"><td class="memItemLeft" align="right" valign="top">constexpr iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a1c15020e334c661e6358e62c6b33943d">insert</a> (const_iterator __position, value_type &amp;&amp;__x)</td></tr>
<tr class="separator:a1c15020e334c661e6358e62c6b33943d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdde128f6bf63d4ace14f920a4caaead"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#afdde128f6bf63d4ace14f920a4caaead">max_size</a> () const noexcept</td></tr>
<tr class="separator:afdde128f6bf63d4ace14f920a4caaead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b2d2e4f6938eb525159f4b7d4d1746"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="a08862.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#ae5b2d2e4f6938eb525159f4b7d4d1746">operator=</a> (const <a class="el" href="a08862.html">vector</a> &amp;__x)</td></tr>
<tr class="separator:ae5b2d2e4f6938eb525159f4b7d4d1746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478b1af8f97315b518147f010668a103"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="a08862.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a478b1af8f97315b518147f010668a103">operator=</a> (<a class="el" href="a01878.html">initializer_list</a>&lt; value_type &gt; __l)</td></tr>
<tr class="separator:a478b1af8f97315b518147f010668a103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa680efff88a932161abd6ea84ea7d2fa"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="a08862.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#aa680efff88a932161abd6ea84ea7d2fa">operator=</a> (<a class="el" href="a08862.html">vector</a> &amp;&amp;__x) noexcept(_Alloc_traits::_S_nothrow_move())</td></tr>
<tr class="separator:aa680efff88a932161abd6ea84ea7d2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88888f54a1db2dd8c1476be814977786"><td class="memItemLeft" align="right" valign="top">constexpr const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a88888f54a1db2dd8c1476be814977786">operator[]</a> (size_type __n) const noexcept</td></tr>
<tr class="separator:a88888f54a1db2dd8c1476be814977786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa114df638f0d7c229718f5d694cf4bd"><td class="memItemLeft" align="right" valign="top">constexpr reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#afa114df638f0d7c229718f5d694cf4bd">operator[]</a> (size_type __n) noexcept</td></tr>
<tr class="separator:afa114df638f0d7c229718f5d694cf4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f4423c75ca0eac42c3211bb372af00"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a50f4423c75ca0eac42c3211bb372af00">pop_back</a> () noexcept</td></tr>
<tr class="separator:a50f4423c75ca0eac42c3211bb372af00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069ff981e0a360ca71ab2682cb4472f4"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a069ff981e0a360ca71ab2682cb4472f4">push_back</a> (const value_type &amp;__x)</td></tr>
<tr class="separator:a069ff981e0a360ca71ab2682cb4472f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2b36f2a48a8f6977e90a8c4b56684a"><td class="memItemLeft" align="right" valign="top"><a id="acc2b36f2a48a8f6977e90a8c4b56684a"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (value_type &amp;&amp;__x)</td></tr>
<tr class="separator:acc2b36f2a48a8f6977e90a8c4b56684a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96de92cb76cca522e3f25233df03cd7d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="a08518.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a96de92cb76cca522e3f25233df03cd7d">rbegin</a> () const noexcept</td></tr>
<tr class="separator:a96de92cb76cca522e3f25233df03cd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba3649c3e29f9088fe48d30ad5a48c6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="a08518.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a0ba3649c3e29f9088fe48d30ad5a48c6">rbegin</a> () noexcept</td></tr>
<tr class="separator:a0ba3649c3e29f9088fe48d30ad5a48c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d388bfcbbdb057bc7db3cae68225b74"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="a08518.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a1d388bfcbbdb057bc7db3cae68225b74">rend</a> () const noexcept</td></tr>
<tr class="separator:a1d388bfcbbdb057bc7db3cae68225b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b14816304e3fa563e76a74d5b73c09"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="a08518.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a95b14816304e3fa563e76a74d5b73c09">rend</a> () noexcept</td></tr>
<tr class="separator:a95b14816304e3fa563e76a74d5b73c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f4b959f742c009837f69ffc7647f00"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a66f4b959f742c009837f69ffc7647f00">reserve</a> (size_type __n)</td></tr>
<tr class="separator:a66f4b959f742c009837f69ffc7647f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c382b5c3db826302c2bb1af46a68f8f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a6c382b5c3db826302c2bb1af46a68f8f">resize</a> (size_type __new_size)</td></tr>
<tr class="separator:a6c382b5c3db826302c2bb1af46a68f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a50ae60e8145e7ef3377523f095dfc9"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a0a50ae60e8145e7ef3377523f095dfc9">resize</a> (size_type __new_size, const value_type &amp;__x)</td></tr>
<tr class="separator:a0a50ae60e8145e7ef3377523f095dfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdabd186225dcb714e388c382cec6cb4"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#afdabd186225dcb714e388c382cec6cb4">shrink_to_fit</a> ()</td></tr>
<tr class="separator:afdabd186225dcb714e388c382cec6cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11d1b1a63bd90ecf4cee85bfbbcdeba"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#ad11d1b1a63bd90ecf4cee85bfbbcdeba">size</a> () const noexcept</td></tr>
<tr class="separator:ad11d1b1a63bd90ecf4cee85bfbbcdeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b09d78602cf28cd1c5dd1c1447c278"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a38b09d78602cf28cd1c5dd1c1447c278">swap</a> (<a class="el" href="a08862.html">vector</a> &amp;__x) noexcept</td></tr>
<tr class="separator:a38b09d78602cf28cd1c5dd1c1447c278"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa556a3f90f5237b62b6efa73902c0f14"><td class="memItemLeft" align="right" valign="top"><a id="aa556a3f90f5237b62b6efa73902c0f14"></a>
constexpr pointer&#160;</td><td class="memItemRight" valign="bottom"><b>_M_allocate</b> (size_t __n)</td></tr>
<tr class="separator:aa556a3f90f5237b62b6efa73902c0f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa556a3f90f5237b62b6efa73902c0f14"><td class="memItemLeft" align="right" valign="top"><a id="aa556a3f90f5237b62b6efa73902c0f14"></a>
constexpr pointer&#160;</td><td class="memItemRight" valign="bottom"><b>_M_allocate</b> (size_t __n)</td></tr>
<tr class="separator:aa556a3f90f5237b62b6efa73902c0f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9292e6d1a9eaf0ad229655271bc15d2a"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:a9292e6d1a9eaf0ad229655271bc15d2a"><td class="memTemplItemLeft" align="right" valign="top">constexpr pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08862.html#a9292e6d1a9eaf0ad229655271bc15d2a">_M_allocate_and_copy</a> (size_type __n, _ForwardIterator __first, _ForwardIterator __last)</td></tr>
<tr class="separator:a9292e6d1a9eaf0ad229655271bc15d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee4c50cd043d498cf60b62225ebf14c"><td class="memTemplParams" colspan="2"><a id="a5ee4c50cd043d498cf60b62225ebf14c"></a>
template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:a5ee4c50cd043d498cf60b62225ebf14c"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_aux</b> (_ForwardIterator __first, _ForwardIterator __last, <a class="el" href="a08630.html">std::forward_iterator_tag</a>)</td></tr>
<tr class="separator:a5ee4c50cd043d498cf60b62225ebf14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4d18925de1aa47569ba105dfc4151b"><td class="memTemplParams" colspan="2"><a id="a3b4d18925de1aa47569ba105dfc4151b"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a3b4d18925de1aa47569ba105dfc4151b"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_aux</b> (_InputIterator __first, _InputIterator __last, <a class="el" href="a08622.html">std::input_iterator_tag</a>)</td></tr>
<tr class="separator:a3b4d18925de1aa47569ba105dfc4151b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ac728ba532de132183b8c7e8bd3779"><td class="memTemplParams" colspan="2"><a id="af3ac728ba532de132183b8c7e8bd3779"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:af3ac728ba532de132183b8c7e8bd3779"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_dispatch</b> (_InputIterator __first, _InputIterator __last, __false_type)</td></tr>
<tr class="separator:af3ac728ba532de132183b8c7e8bd3779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02c5b54def5697d64a692b215c9c948"><td class="memTemplParams" colspan="2"><a id="ae02c5b54def5697d64a692b215c9c948"></a>
template&lt;typename _Integer &gt; </td></tr>
<tr class="memitem:ae02c5b54def5697d64a692b215c9c948"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_dispatch</b> (_Integer __n, _Integer __val, __true_type)</td></tr>
<tr class="separator:ae02c5b54def5697d64a692b215c9c948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab04a729ebc46f41aabb92a8cb5e40be"><td class="memItemLeft" align="right" valign="top"><a id="aab04a729ebc46f41aabb92a8cb5e40be"></a>
constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><b>_M_check_len</b> (size_type __n, const char *__s) const</td></tr>
<tr class="separator:aab04a729ebc46f41aabb92a8cb5e40be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7408a19203d148207b894292fd327e"><td class="memItemLeft" align="right" valign="top"><a id="a9c7408a19203d148207b894292fd327e"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_create_storage</b> (size_t __n)</td></tr>
<tr class="separator:a9c7408a19203d148207b894292fd327e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c3b0e0e0947e973998ca065584a56f"><td class="memItemLeft" align="right" valign="top"><a id="ac0c3b0e0e0947e973998ca065584a56f"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_deallocate</b> (pointer __p, size_t __n)</td></tr>
<tr class="separator:ac0c3b0e0e0947e973998ca065584a56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c3b0e0e0947e973998ca065584a56f"><td class="memItemLeft" align="right" valign="top"><a id="ac0c3b0e0e0947e973998ca065584a56f"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_deallocate</b> (pointer __p, size_t __n)</td></tr>
<tr class="separator:ac0c3b0e0e0947e973998ca065584a56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102477e777c50ccf16b9c11b37173233"><td class="memItemLeft" align="right" valign="top"><a id="a102477e777c50ccf16b9c11b37173233"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_default_append</b> (size_type __n)</td></tr>
<tr class="separator:a102477e777c50ccf16b9c11b37173233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464677882effde8b6abffd4149e97ce9"><td class="memItemLeft" align="right" valign="top"><a id="a464677882effde8b6abffd4149e97ce9"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_default_initialize</b> (size_type __n)</td></tr>
<tr class="separator:a464677882effde8b6abffd4149e97ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845a90564073f676c6ece84e67288091"><td class="memTemplParams" colspan="2"><a id="a845a90564073f676c6ece84e67288091"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a845a90564073f676c6ece84e67288091"><td class="memTemplItemLeft" align="right" valign="top">constexpr iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_emplace_aux</b> (const_iterator __position, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a845a90564073f676c6ece84e67288091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49959079e63bdd78ddc03d71532d648d"><td class="memItemLeft" align="right" valign="top"><a id="a49959079e63bdd78ddc03d71532d648d"></a>
constexpr iterator&#160;</td><td class="memItemRight" valign="bottom"><b>_M_emplace_aux</b> (const_iterator __position, value_type &amp;&amp;__v)</td></tr>
<tr class="separator:a49959079e63bdd78ddc03d71532d648d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ab62a48317ec62be87cee259419aa1"><td class="memItemLeft" align="right" valign="top"><a id="a37ab62a48317ec62be87cee259419aa1"></a>
constexpr iterator&#160;</td><td class="memItemRight" valign="bottom"><b>_M_erase</b> (iterator __first, iterator __last)</td></tr>
<tr class="separator:a37ab62a48317ec62be87cee259419aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3884c422ba4e7c35a58200a78ed6f4"><td class="memItemLeft" align="right" valign="top"><a id="a8b3884c422ba4e7c35a58200a78ed6f4"></a>
constexpr iterator&#160;</td><td class="memItemRight" valign="bottom"><b>_M_erase</b> (iterator __position)</td></tr>
<tr class="separator:a8b3884c422ba4e7c35a58200a78ed6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68746d7c620d680acb35fe119c289ae0"><td class="memItemLeft" align="right" valign="top"><a id="a68746d7c620d680acb35fe119c289ae0"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_erase_at_end</b> (pointer __pos) noexcept</td></tr>
<tr class="separator:a68746d7c620d680acb35fe119c289ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c8761abff18e60d5288a003f6b87e7"><td class="memItemLeft" align="right" valign="top"><a id="a95c8761abff18e60d5288a003f6b87e7"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_fill_assign</b> (size_type __n, const value_type &amp;__val)</td></tr>
<tr class="separator:a95c8761abff18e60d5288a003f6b87e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ef72ef09fb5afd14f0c1997e681a39"><td class="memItemLeft" align="right" valign="top"><a id="aa5ef72ef09fb5afd14f0c1997e681a39"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_fill_initialize</b> (size_type __n, const value_type &amp;__value)</td></tr>
<tr class="separator:aa5ef72ef09fb5afd14f0c1997e681a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40686e51af3a8c73d6c47e9a94490c7"><td class="memItemLeft" align="right" valign="top"><a id="ae40686e51af3a8c73d6c47e9a94490c7"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_fill_insert</b> (iterator __pos, size_type __n, const value_type &amp;__x)</td></tr>
<tr class="separator:ae40686e51af3a8c73d6c47e9a94490c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b806df40a04a68a5ebeb0c3c2af1ff"><td class="memItemLeft" align="right" valign="top"><a id="ae1b806df40a04a68a5ebeb0c3c2af1ff"></a>
constexpr const _Tp_alloc_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_M_get_Tp_allocator</b> () const noexcept</td></tr>
<tr class="separator:ae1b806df40a04a68a5ebeb0c3c2af1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b806df40a04a68a5ebeb0c3c2af1ff"><td class="memItemLeft" align="right" valign="top"><a id="ae1b806df40a04a68a5ebeb0c3c2af1ff"></a>
constexpr const _Tp_alloc_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_M_get_Tp_allocator</b> () const noexcept</td></tr>
<tr class="separator:ae1b806df40a04a68a5ebeb0c3c2af1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab533e69fbf969ae1a3ca8f9a07a863a2"><td class="memItemLeft" align="right" valign="top"><a id="ab533e69fbf969ae1a3ca8f9a07a863a2"></a>
constexpr _Tp_alloc_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_M_get_Tp_allocator</b> () noexcept</td></tr>
<tr class="separator:ab533e69fbf969ae1a3ca8f9a07a863a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49404fbfa252a5970ce29babf806930"><td class="memTemplParams" colspan="2"><a id="af49404fbfa252a5970ce29babf806930"></a>
template&lt;typename _Arg &gt; </td></tr>
<tr class="memitem:af49404fbfa252a5970ce29babf806930"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_insert_aux</b> (iterator __position, _Arg &amp;&amp;__arg)</td></tr>
<tr class="separator:af49404fbfa252a5970ce29babf806930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2961d81dc428f76b9ee5fe966e7112c3"><td class="memTemplParams" colspan="2"><a id="a2961d81dc428f76b9ee5fe966e7112c3"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a2961d81dc428f76b9ee5fe966e7112c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_insert_dispatch</b> (iterator __pos, _InputIterator __first, _InputIterator __last, __false_type)</td></tr>
<tr class="separator:a2961d81dc428f76b9ee5fe966e7112c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8052695d205403a01b3e664067289688"><td class="memTemplParams" colspan="2"><a id="a8052695d205403a01b3e664067289688"></a>
template&lt;typename _Integer &gt; </td></tr>
<tr class="memitem:a8052695d205403a01b3e664067289688"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_insert_dispatch</b> (iterator __pos, _Integer __n, _Integer __val, __true_type)</td></tr>
<tr class="separator:a8052695d205403a01b3e664067289688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d0d24c8963b1a539a04c5c0bdf3db9"><td class="memItemLeft" align="right" valign="top"><a id="a69d0d24c8963b1a539a04c5c0bdf3db9"></a>
constexpr iterator&#160;</td><td class="memItemRight" valign="bottom"><b>_M_insert_rval</b> (const_iterator __position, value_type &amp;&amp;__v)</td></tr>
<tr class="separator:a69d0d24c8963b1a539a04c5c0bdf3db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c50e1aa3a380ef0ae30343d22633800"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08862.html#a7c50e1aa3a380ef0ae30343d22633800">_M_range_check</a> (size_type __n) const</td></tr>
<tr class="separator:a7c50e1aa3a380ef0ae30343d22633800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eadad1b8d04c8765c6a30717883e2c"><td class="memTemplParams" colspan="2"><a id="a40eadad1b8d04c8765c6a30717883e2c"></a>
template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:a40eadad1b8d04c8765c6a30717883e2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_range_initialize</b> (_ForwardIterator __first, _ForwardIterator __last, <a class="el" href="a08630.html">std::forward_iterator_tag</a>)</td></tr>
<tr class="separator:a40eadad1b8d04c8765c6a30717883e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd420f2023e577415dc99c673c5a61a3"><td class="memTemplParams" colspan="2"><a id="acd420f2023e577415dc99c673c5a61a3"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:acd420f2023e577415dc99c673c5a61a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_range_initialize</b> (_InputIterator __first, _InputIterator __last, <a class="el" href="a08622.html">std::input_iterator_tag</a>)</td></tr>
<tr class="separator:acd420f2023e577415dc99c673c5a61a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d43a443ac240cea08c7df52fe13ede"><td class="memTemplParams" colspan="2"><a id="a68d43a443ac240cea08c7df52fe13ede"></a>
template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:a68d43a443ac240cea08c7df52fe13ede"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_range_insert</b> (iterator __pos, _ForwardIterator __first, _ForwardIterator __last, <a class="el" href="a08630.html">std::forward_iterator_tag</a>)</td></tr>
<tr class="separator:a68d43a443ac240cea08c7df52fe13ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1d7235a017a610b68dcc07db90d4bc"><td class="memTemplParams" colspan="2"><a id="a3b1d7235a017a610b68dcc07db90d4bc"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a3b1d7235a017a610b68dcc07db90d4bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_range_insert</b> (iterator __pos, _InputIterator __first, _InputIterator __last, <a class="el" href="a08622.html">std::input_iterator_tag</a>)</td></tr>
<tr class="separator:a3b1d7235a017a610b68dcc07db90d4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37a3e36eb066aaca7d0f098278abd00"><td class="memTemplParams" colspan="2"><a id="ad37a3e36eb066aaca7d0f098278abd00"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:ad37a3e36eb066aaca7d0f098278abd00"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_realloc_insert</b> (iterator __position, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:ad37a3e36eb066aaca7d0f098278abd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392b0204a36a0d295d91374898ba5958"><td class="memItemLeft" align="right" valign="top"><a id="a392b0204a36a0d295d91374898ba5958"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>_M_shrink_to_fit</b> ()</td></tr>
<tr class="separator:a392b0204a36a0d295d91374898ba5958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e13307a83139885af1475b01cfd4a8"><td class="memItemLeft" align="right" valign="top"><a id="ac2e13307a83139885af1475b01cfd4a8"></a>
constexpr allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const noexcept</td></tr>
<tr class="separator:ac2e13307a83139885af1475b01cfd4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a761abdca52c021ea555d407b541de566"><td class="memItemLeft" align="right" valign="top"><a id="a761abdca52c021ea555d407b541de566"></a>
static constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><b>_S_check_init_len</b> (size_type __n, const allocator_type &amp;__a)</td></tr>
<tr class="separator:a761abdca52c021ea555d407b541de566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f326d9fbaad9119425e1b9a558e56f3"><td class="memItemLeft" align="right" valign="top"><a id="a7f326d9fbaad9119425e1b9a558e56f3"></a>
static constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><b>_S_max_size</b> (const _Tp_alloc_type &amp;__a) noexcept</td></tr>
<tr class="separator:a7f326d9fbaad9119425e1b9a558e56f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1f01a554f9c151b5b56ab81b8da228bd"><td class="memItemLeft" align="right" valign="top"><a id="a1f01a554f9c151b5b56ab81b8da228bd"></a>
_Vector_impl&#160;</td><td class="memItemRight" valign="bottom"><b>_M_impl</b></td></tr>
<tr class="separator:a1f01a554f9c151b5b56ab81b8da228bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;<br />
class std::vector&lt; _Tp, _Alloc &gt;</h3>

<p>A standard container which offers fixed time access to individual elements in any order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Type of element. </td></tr>
    <tr><td class="paramname">_Alloc</td><td>Allocator type, defaults to allocator&lt;_Tp&gt;.</td></tr>
  </table>
  </dd>
</dl>
<p>Meets the requirements of a <a href="tables.html#65">container</a>, a <a href="tables.html#66">reversible container</a>, and a <a href="tables.html#67">sequence</a>, including the <a href="tables.html#68">optional sequence requirements</a> with the exception of <code>push_front</code> and <code>pop_front</code>.</p>
<p>In some terminology a vector can be described as a dynamic C-style array, it offers fast and efficient access to individual elements in any order and saves the user from worrying about memory and size allocation. Subscripting ( <code></code>[] ) access is also provided as with C-style arrays. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00423">423</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1629a99cef9608b6d37cb67ce1e5c058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1629a99cef9608b6d37cb67ce1e5c058">&#9670;&nbsp;</a></span>vector() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a08862.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vector with no elements. </p>

</div>
</div>
<a id="a8ebcef120d19a26b2b2ba0dfdceb2ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ebcef120d19a26b2b2ba0dfdceb2ad7">&#9670;&nbsp;</a></span>vector() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a08862.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vector with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00537">537</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a46234923032a08ecb8800b880bb2975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46234923032a08ecb8800b880bb2975e">&#9670;&nbsp;</a></span>vector() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a08862.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vector with default constructed elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The number of elements to initially create. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor fills the vector with <em>__n</em> default constructed elements. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00551">551</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="ae24d71d1f19e3161ffdc5c41b0c594ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24d71d1f19e3161ffdc5c41b0c594ae">&#9670;&nbsp;</a></span>vector() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a08862.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vector with copies of an exemplar element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The number of elements to initially create. </td></tr>
    <tr><td class="paramname">__value</td><td>An element to copy. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor fills the vector with <em>__n</em> copies of <em>__value</em>. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00564">564</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a15b6b19021c96e2c33f21034a4532ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b6b19021c96e2c33f21034a4532ff0">&#9670;&nbsp;</a></span>vector() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a08862.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08862.html">vector</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A vector of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>All the elements of <em>__x</em> are copied, but any unused capacity in <em>__x</em> will not be copied (i.e. capacity() == size() in the new vector).</p>
<p>The newly-created vector uses a copy of the allocator object used by <em>__x</em> (unless the allocator traits dictate a different object). </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00596">596</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00868">std::vector&lt; _Tp, _Alloc &gt;::begin()</a>, and <a class="el" href="a00722_source.html#l00888">std::vector&lt; _Tp, _Alloc &gt;::end()</a>.</p>

</div>
</div>
<a id="ab046bf21cbed50d0847f467a3b6d463a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab046bf21cbed50d0847f467a3b6d463a">&#9670;&nbsp;</a></span>vector() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a08862.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08862.html">vector</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector move constructor. </p>
<p>The newly-created vector contains the exact contents of the moved instance. The contents of the moved instance are a valid, but unspecified vector. </p>

</div>
</div>
<a id="aba8313a199bf28ee8387348dede2f6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8313a199bf28ee8387348dede2f6d4">&#9670;&nbsp;</a></span>vector() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a08862.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08862.html">vector</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const __type_identity_t&lt; allocator_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with alternative allocator. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00619">619</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a3f7bf79e9024376071a3e87bb7bf6c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7bf79e9024376071a3e87bb7bf6c12">&#9670;&nbsp;</a></span>vector() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a08862.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08862.html">vector</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const __type_identity_t&lt; allocator_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>__m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with alternative allocator. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00654">654</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="aac2717e4081a34b11645c512a5781ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2717e4081a34b11645c512a5781ebc">&#9670;&nbsp;</a></span>vector() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a08862.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">initializer_list</a>&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a vector from an initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a vector consisting of copies of the elements in the initializer_list <em>__l</em>.</p>
<p>This will call the element type's copy constructor N times (where N is <em>__l.size()</em>) and do no memory reallocation. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00673">673</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="aab5e214249faa99bbc16b98ab7336ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5e214249faa99bbc16b98ab7336ab4">&#9670;&nbsp;</a></span>vector() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a08862.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a vector from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a vector consisting of copies of the elements from [first,last).</p>
<p>If the iterators are forward, bidirectional, or random-access, then this will call the elements' copy constructor N times (where N is distance(first,last)) and do no memory reallocation. But if only input iterators are used, then this will do at most 2N calls to the copy constructor, and logN memory reallocations. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00702">702</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00677_source.html#l00238">std::__iterator_category()</a>.</p>

</div>
</div>
<a id="a27f5f67acef67281a696cdc88e27fe6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f5f67acef67281a696cdc88e27fe6f">&#9670;&nbsp;</a></span>~vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::~<a class="el" href="a08862.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00728">728</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a19243_source.html#l00832">std::_Destroy()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9292e6d1a9eaf0ad229655271bc15d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9292e6d1a9eaf0ad229655271bc15d2a">&#9670;&nbsp;</a></span>_M_allocate_and_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr pointer <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::_M_allocate_and_copy </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Memory expansion handler. Uses the member allocation function to obtain <em>n</em> bytes of memory, and then copies [first,last) into it. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01611">1611</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a7c50e1aa3a380ef0ae30343d22633800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c50e1aa3a380ef0ae30343d22633800">&#9670;&nbsp;</a></span>_M_range_check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::_M_range_check </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safety check used only from at(). </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01150">1150</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00987">std::vector&lt; _Tp, _Alloc &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00722_source.html#l01173">std::vector&lt; _Tp, _Alloc &gt;::at()</a>.</p>

</div>
</div>
<a id="a29c4ec50d0c01b54a99483e9a2e62404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c4ec50d0c01b54a99483e9a2e62404">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a range to a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a vector with copies of the elements in the range [__first,__last).</p>
<p>Note that the assignment completely changes the vector and that the resulting vector's size is the same as the number of elements assigned. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00823">823</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="abb2457f1d9d156b6683a57944fa61084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2457f1d9d156b6683a57944fa61084">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">initializer_list</a>&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an initializer list to a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a vector with copies of the elements in the initializer list <em>__l</em>.</p>
<p>Note that the assignment completely changes the vector and that the resulting vector's size is the same as the number of elements assigned. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00850">850</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a2d3100ced0975b432bed6e7b793f056f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3100ced0975b432bed6e7b793f056f">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a given value to a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Number of elements to be assigned. </td></tr>
    <tr><td class="paramname">__val</td><td>Value to be assigned.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a vector with <em>__n</em> copies of the given value. Note that the assignment completely changes the vector and that the resulting vector's size is the same as the number of elements assigned. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00803">803</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a66f5788cba9bc9c69b07420bc31dcf2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f5788cba9bc9c69b07420bc31dcf2e">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr reference <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the data contained in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>__n</em> is an invalid index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides for safer data access. The parameter is first checked that it is in the range of the vector. The function throws out_of_range if the check fails. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01173">1173</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l01150">std::vector&lt; _Tp, _Alloc &gt;::_M_range_check()</a>.</p>

</div>
</div>
<a id="aa82d70daf901ebe75d471bb6d1eefb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82d70daf901ebe75d471bb6d1eefb67">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reference <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the data contained in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) reference to data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>__n</em> is an invalid index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides for safer data access. The parameter is first checked that it is in the range of the vector. The function throws out_of_range if the check fails. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01192">1192</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l01150">std::vector&lt; _Tp, _Alloc &gt;::_M_range_check()</a>.</p>

</div>
</div>
<a id="a6548c1e0ab1200834070170bd76f07cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6548c1e0ab1200834070170bd76f07cc">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reference <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reference to the data at the last element of the vector. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01240">1240</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="aef70c7e68b53c133dd35cd871fbcfb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef70c7e68b53c133dd35cd871fbcfb19">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr reference <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reference to the data at the last element of the vector. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01228">1228</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00551_source.html#l05677">std::piecewise_constant_distribution&lt; _RealType &gt;::max()</a>, and <a class="el" href="a00551_source.html#l05950">std::piecewise_linear_distribution&lt; _RealType &gt;::max()</a>.</p>

</div>
</div>
<a id="a28b3247394c6a5110b39b89dc8a310bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b3247394c6a5110b39b89dc8a310bd">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the vector. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00878">878</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a1fa4b1c4fd03874d5e43877c3e466ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa4b1c4fd03874d5e43877c3e466ee8">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points to the first element in the vector. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00868">868</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00722_source.html#l00596">std::vector&lt; _Tp, _Alloc &gt;::vector()</a>, <a class="el" href="a00581_source.html#l01938">std::match_results&lt; _Bi_iter, _Alloc &gt;::begin()</a>, <a class="el" href="a00722_source.html#l00979">std::vector&lt; _Tp, _Alloc &gt;::crend()</a>, <a class="el" href="a00722_source.html#l01083">std::vector&lt; _Tp, _Alloc &gt;::empty()</a>, <a class="el" href="a00722_source.html#l01529">std::vector&lt; _Tp, _Alloc &gt;::erase()</a>, <a class="el" href="a00722_source.html#l01406">std::vector&lt; _Tp, _Alloc &gt;::insert()</a>, <a class="el" href="a00722_source.html#l02074">std::operator&lt;()</a>, <a class="el" href="a00722_source.html#l02035">std::operator==()</a>, and <a class="el" href="a00722_source.html#l00928">std::vector&lt; _Tp, _Alloc &gt;::rend()</a>.</p>

</div>
</div>
<a id="a22049143588a50ab6b1fc555e689b9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22049143588a50ab6b1fc555e689b9c7">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_type <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the total number of elements that the vector can hold before needing to allocate more memory. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01073">1073</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="aaa81688ee8ea9b9d787a38463c631940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa81688ee8ea9b9d787a38463c631940">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the vector. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00949">949</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00722_source.html#l01529">std::vector&lt; _Tp, _Alloc &gt;::erase()</a>, and <a class="el" href="a00722_source.html#l01406">std::vector&lt; _Tp, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a id="af8b1709557966323d397a8d5ef658415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b1709557966323d397a8d5ef658415">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the vector. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00959">959</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="ab9c08a435f4bdcba3ba3e74e50a6d23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c08a435f4bdcba3ba3e74e50a6d23c">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all the elements. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01600">1600</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a9a8c92caa3ad719523d4cef67aa46518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8c92caa3ad719523d4cef67aa46518">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08518.html">const_reverse_iterator</a> <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to the last element in the vector. Iteration is done in reverse element order. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00969">969</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00888">std::vector&lt; _Tp, _Alloc &gt;::end()</a>.</p>

</div>
</div>
<a id="af4e43d049d329f67ffd424d61c4ecb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e43d049d329f67ffd424d61c4ecb5f">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08518.html">const_reverse_iterator</a> <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to one before the first element in the vector. Iteration is done in reverse element order. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00979">979</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00868">std::vector&lt; _Tp, _Alloc &gt;::begin()</a>.</p>

</div>
</div>
<a id="a4e845611f07919062c843fa5ab364ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e845611f07919062c843fa5ab364ab1">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _Tp* <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer such that [data(), data() + size()) is a valid range. For a non-empty vector, data() == &amp;front(). </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01255">1255</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a162bbd57ea9dad26ccf3aae78e98c4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162bbd57ea9dad26ccf3aae78e98c4ba">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an object in vector before specified iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the vector. </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert an object of type T constructed with T(std::forward&lt;Args&gt;(args)...) before the specified location. Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using std::list. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01341">1341</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a929d5baba01bee31ac909918be338655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929d5baba01bee31ac909918be338655">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the vector is empty. (Thus begin() would equal end().) </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01083">1083</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00868">std::vector&lt; _Tp, _Alloc &gt;::begin()</a>, and <a class="el" href="a00722_source.html#l00888">std::vector&lt; _Tp, _Alloc &gt;::end()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00551_source.html#l05642">std::piecewise_constant_distribution&lt; _RealType &gt;::densities()</a>, <a class="el" href="a00551_source.html#l05915">std::piecewise_linear_distribution&lt; _RealType &gt;::densities()</a>, <a class="el" href="a00581_source.html#l01952">std::match_results&lt; _Bi_iter, _Alloc &gt;::end()</a>, <a class="el" href="a00551_source.html#l05626">std::piecewise_constant_distribution&lt; _RealType &gt;::intervals()</a>, <a class="el" href="a00551_source.html#l05898">std::piecewise_linear_distribution&lt; _RealType &gt;::intervals()</a>, <a class="el" href="a00551_source.html#l05407">std::discrete_distribution&lt; _IntType &gt;::max()</a>, <a class="el" href="a00551_source.html#l05677">std::piecewise_constant_distribution&lt; _RealType &gt;::max()</a>, <a class="el" href="a00551_source.html#l05950">std::piecewise_linear_distribution&lt; _RealType &gt;::max()</a>, <a class="el" href="a00551_source.html#l05667">std::piecewise_constant_distribution&lt; _RealType &gt;::min()</a>, <a class="el" href="a00551_source.html#l05940">std::piecewise_linear_distribution&lt; _RealType &gt;::min()</a>, <a class="el" href="a00551_source.html#l05375">std::discrete_distribution&lt; _IntType &gt;::probabilities()</a>, <a class="el" href="a00581_source.html#l01804">std::match_results&lt; _Bi_iter, _Alloc &gt;::ready()</a>, and <a class="el" href="a00581_source.html#l01821">std::match_results&lt; _Bi_iter, _Alloc &gt;::size()</a>.</p>

</div>
</div>
<a id="aad5f353afd4e55321e07e5516faea08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5f353afd4e55321e07e5516faea08c">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the vector. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00898">898</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a0e6603dd1f0d71126f4429596abf0ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6603dd1f0d71126f4429596abf0ca4">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points one past the last element in the vector. Iteration is done in ordinary element order. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00888">888</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00722_source.html#l00596">std::vector&lt; _Tp, _Alloc &gt;::vector()</a>, <a class="el" href="a00722_source.html#l00969">std::vector&lt; _Tp, _Alloc &gt;::crbegin()</a>, <a class="el" href="a00722_source.html#l01083">std::vector&lt; _Tp, _Alloc &gt;::empty()</a>, <a class="el" href="a00581_source.html#l01952">std::match_results&lt; _Bi_iter, _Alloc &gt;::end()</a>, <a class="el" href="a00722_source.html#l02074">std::operator&lt;()</a>, <a class="el" href="a00722_source.html#l02035">std::operator==()</a>, <a class="el" href="a00722_source.html#l00908">std::vector&lt; _Tp, _Alloc &gt;::rbegin()</a>, and <a class="el" href="a00722_source.html#l01029">std::vector&lt; _Tp, _Alloc &gt;::resize()</a>.</p>

</div>
</div>
<a id="a3891eac8d375a8f1f8c1817ee40e3006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3891eac8d375a8f1f8c1817ee40e3006">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the first element to be erased. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to one past the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element pointed to by <em>__last</em> prior to erasing (or end()).</dd></dl>
<p>This function will erase the elements in the range [__first,__last) and shorten the vector accordingly.</p>
<p>Note This operation could be expensive and if it is frequently used the user should consider using std::list. The user is also cautioned that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01557">1557</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00868">std::vector&lt; _Tp, _Alloc &gt;::begin()</a>, and <a class="el" href="a00722_source.html#l00949">std::vector&lt; _Tp, _Alloc &gt;::cbegin()</a>.</p>

</div>
</div>
<a id="a91fc09b351a61fabdffebcb22012a0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fc09b351a61fabdffebcb22012a0d8">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove element at given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>Iterator pointing to element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the next element (or end()).</dd></dl>
<p>This function will erase the element at the given position and thus shorten the vector by one.</p>
<p>Note This operation could be expensive and if it is frequently used the user should consider using std::list. The user is also cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01529">1529</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00868">std::vector&lt; _Tp, _Alloc &gt;::begin()</a>, and <a class="el" href="a00722_source.html#l00949">std::vector&lt; _Tp, _Alloc &gt;::cbegin()</a>.</p>

</div>
</div>
<a id="a4761caae3c1584f90278198de30cb1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4761caae3c1584f90278198de30cb1d7">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reference <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reference to the data at the first element of the vector. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01216">1216</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a7e0ffd29fde812666b492d05848b7414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0ffd29fde812666b492d05848b7414">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr reference <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reference to the data at the first element of the vector. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01204">1204</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00551_source.html#l05667">std::piecewise_constant_distribution&lt; _RealType &gt;::min()</a>, and <a class="el" href="a00551_source.html#l05940">std::piecewise_linear_distribution&lt; _RealType &gt;::min()</a>.</p>

</div>
</div>
<a id="ac2e13307a83139885af1475b01cfd4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e13307a83139885af1475b01cfd4a8">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr allocator_type <a class="el" href="a08850.html">std::_Vector_base</a>&lt; _Tp, _Alloc &gt;::get_allocator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the memory allocation object. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00308">308</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00581_source.html#l02034">std::match_results&lt; _Bi_iter, _Alloc &gt;::get_allocator()</a>.</p>

</div>
</div>
<a id="ab547528b49a234720493fce03da17d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab547528b49a234720493fce03da17d45">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a range into the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the vector. </td></tr>
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert copies of the data in the range [__first,__last) into the vector before the location specified by <em>pos</em>.</p>
<p>Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using std::list. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01477">1477</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00868">std::vector&lt; _Tp, _Alloc &gt;::begin()</a>, and <a class="el" href="a00722_source.html#l00949">std::vector&lt; _Tp, _Alloc &gt;::cbegin()</a>.</p>

</div>
</div>
<a id="a022eaccfa36211f2ea979703414dd357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022eaccfa36211f2ea979703414dd357">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">vector</a>&lt; _Tp, _Alloc &gt;::iterator vector::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts given value into vector before specified iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the vector. </td></tr>
    <tr><td class="paramname">__x</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert a copy of the given value before the specified location. Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using std::list. </p>

<p class="definition">Definition at line <a class="el" href="a00779_source.html#l00133">133</a> of file <a class="el" href="a00779_source.html">vector.tcc</a>.</p>

<p class="reference">References <a class="el" href="a00239_source.html#l01215">std::begin()</a>, and <a class="el" href="a00239_source.html#l01237">std::end()</a>.</p>

</div>
</div>
<a id="a2505d5c509abc7eab6d9fedbd8d68c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2505d5c509abc7eab6d9fedbd8d68c41">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01878.html">initializer_list</a>&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an initializer_list into the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator into the vector. </td></tr>
    <tr><td class="paramname">__l</td><td>An initializer_list.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will insert copies of the data in the initializer_list <em>l</em> into the vector before the location specified by <em>position</em>.</p>
<p>Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using std::list. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01406">1406</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00868">std::vector&lt; _Tp, _Alloc &gt;::begin()</a>, and <a class="el" href="a00722_source.html#l00949">std::vector&lt; _Tp, _Alloc &gt;::cbegin()</a>.</p>

</div>
</div>
<a id="a8711eff0025743446d83b5bf9ac1d3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8711eff0025743446d83b5bf9ac1d3eb">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a number of copies of given data into the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the vector. </td></tr>
    <tr><td class="paramname">__n</td><td>Number of elements to be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert a specified number of copies of the given data before the location specified by <em>position</em>.</p>
<p>Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using std::list. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01432">1432</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00868">std::vector&lt; _Tp, _Alloc &gt;::begin()</a>, and <a class="el" href="a00722_source.html#l00949">std::vector&lt; _Tp, _Alloc &gt;::cbegin()</a>.</p>

</div>
</div>
<a id="a1c15020e334c661e6358e62c6b33943d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c15020e334c661e6358e62c6b33943d">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr iterator <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts given rvalue into vector before specified iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the vector. </td></tr>
    <tr><td class="paramname">__x</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert a copy of the given rvalue before the specified location. Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using std::list. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01388">1388</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="afdde128f6bf63d4ace14f920a4caaead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdde128f6bf63d4ace14f920a4caaead">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_type <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size() of the largest possible vector. <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00993">993</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00581_source.html#l01825">std::match_results&lt; _Bi_iter, _Alloc &gt;::max_size()</a>.</p>

</div>
</div>
<a id="ae5b2d2e4f6938eb525159f4b7d4d1746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b2d2e4f6938eb525159f4b7d4d1746">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">vector</a>&lt; _Tp, _Alloc &gt; &amp; vector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08862.html">vector</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A vector of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>All the elements of <em>__x</em> are copied, but any unused capacity in <em>__x</em> will not be copied.</p>
<p>Whether the allocator is copied depends on the allocator traits. </p>

<p class="definition">Definition at line <a class="el" href="a00779_source.html#l00204">204</a> of file <a class="el" href="a00779_source.html">vector.tcc</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00049">std::__addressof()</a>.</p>

</div>
</div>
<a id="a478b1af8f97315b518147f010668a103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478b1af8f97315b518147f010668a103">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">vector</a>&amp; <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">initializer_list</a>&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector list assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a vector with copies of the elements in the initializer list <em>__l</em>.</p>
<p>Note that the assignment completely changes the vector and that the resulting vector's size is the same as the number of elements assigned. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00783">783</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="aa680efff88a932161abd6ea84ea7d2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa680efff88a932161abd6ea84ea7d2fa">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08862.html">vector</a>&amp; <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08862.html">vector</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A vector of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>The contents of <em>__x</em> are moved into this vector (without copying, if the allocators permit it). Afterwards <em>__x</em> is a valid, but unspecified vector.</p>
<p>Whether the allocator is moved depends on the allocator traits. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00761">761</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="a88888f54a1db2dd8c1476be814977786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88888f54a1db2dd8c1476be814977786">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const_reference <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript access to the data contained in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. (For checked lookups see at().) </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01140">1140</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="afa114df638f0d7c229718f5d694cf4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa114df638f0d7c229718f5d694cf4bd">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr reference <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript access to the data contained in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. (For checked lookups see at().) </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01121">1121</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a50f4423c75ca0eac42c3211bb372af00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f4423c75ca0eac42c3211bb372af00">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes last element. </p>
<p>This is a typical stack operation. It shrinks the vector by one.</p>
<p>Note that no data is returned, and if the last element's data is needed, it should be retrieved before pop_back() is called. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01317">1317</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a069ff981e0a360ca71ab2682cb4472f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069ff981e0a360ca71ab2682cb4472f4">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the end of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Data to be added.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a typical stack operation. The function creates an element at the end of the vector and assigns the given data to it. Due to the nature of a vector this operation can be done in constant time if the vector has preallocated space available. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01276">1276</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="a96de92cb76cca522e3f25233df03cd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96de92cb76cca522e3f25233df03cd7d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08518.html">const_reverse_iterator</a> <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to the last element in the vector. Iteration is done in reverse element order. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00918">918</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00888">std::vector&lt; _Tp, _Alloc &gt;::end()</a>.</p>

</div>
</div>
<a id="a0ba3649c3e29f9088fe48d30ad5a48c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba3649c3e29f9088fe48d30ad5a48c6">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08518.html">reverse_iterator</a> <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reverse iterator that points to the last element in the vector. Iteration is done in reverse element order. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00908">908</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00888">std::vector&lt; _Tp, _Alloc &gt;::end()</a>.</p>

</div>
</div>
<a id="a1d388bfcbbdb057bc7db3cae68225b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d388bfcbbdb057bc7db3cae68225b74">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08518.html">const_reverse_iterator</a> <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to one before the first element in the vector. Iteration is done in reverse element order. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00938">938</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00868">std::vector&lt; _Tp, _Alloc &gt;::begin()</a>.</p>

</div>
</div>
<a id="a95b14816304e3fa563e76a74d5b73c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b14816304e3fa563e76a74d5b73c09">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08518.html">reverse_iterator</a> <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reverse iterator that points to one before the first element in the vector. Iteration is done in reverse element order. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00928">928</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00868">std::vector&lt; _Tp, _Alloc &gt;::begin()</a>.</p>

</div>
</div>
<a id="a66f4b959f742c009837f69ffc7647f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f4b959f742c009837f69ffc7647f00">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void vector::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to preallocate enough memory for specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Number of elements required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>If <em>n</em> exceeds <code>max_size()</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function attempts to reserve enough memory for the vector to hold the specified number of elements. If the number requested is more than max_size(), length_error is thrown.</p>
<p>The advantage of this function is that if optimal code is a necessity and the user can determine the number of elements that will be required, the user can reserve the memory in advance, and thus prevent a possible reallocation of memory and copying of vector data. </p>

<p class="definition">Definition at line <a class="el" href="a00779_source.html#l00067">67</a> of file <a class="el" href="a00779_source.html">vector.tcc</a>.</p>

</div>
</div>
<a id="a6c382b5c3db826302c2bb1af46a68f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c382b5c3db826302c2bb1af46a68f8f">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the vector to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__new_size</td><td>Number of elements the vector should contain.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will resize the vector to the specified number of elements. If the number is smaller than the vector's current size the vector is truncated, otherwise default constructed elements are appended. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01008">1008</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00987">std::vector&lt; _Tp, _Alloc &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00992_source.html#l00050">__gnu_parallel::__shrink_and_double()</a>.</p>

</div>
</div>
<a id="a0a50ae60e8145e7ef3377523f095dfc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a50ae60e8145e7ef3377523f095dfc9">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the vector to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__new_size</td><td>Number of elements the vector should contain. </td></tr>
    <tr><td class="paramname">__x</td><td>Data with which new elements should be populated.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will resize the vector to the specified number of elements. If the number is smaller than the vector's current size the vector is truncated, otherwise the vector is extended and new elements are populated with given data. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01029">1029</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">References <a class="el" href="a00722_source.html#l00888">std::vector&lt; _Tp, _Alloc &gt;::end()</a>, and <a class="el" href="a00722_source.html#l00987">std::vector&lt; _Tp, _Alloc &gt;::size()</a>.</p>

</div>
</div>
<a id="afdabd186225dcb714e388c382cec6cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdabd186225dcb714e388c382cec6cb4">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A non-binding request to reduce capacity() to size(). <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01063">1063</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

</div>
</div>
<a id="ad11d1b1a63bd90ecf4cee85bfbbcdeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11d1b1a63bd90ecf4cee85bfbbcdeba">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_type <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the vector. <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l00987">987</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00992_source.html#l00070">__gnu_parallel::__shrink()</a>, <a class="el" href="a00992_source.html#l00050">__gnu_parallel::__shrink_and_double()</a>, <a class="el" href="a00722_source.html#l01150">std::vector&lt; _Tp, _Alloc &gt;::_M_range_check()</a>, <a class="el" href="a00581_source.html#l01834">std::match_results&lt; _Bi_iter, _Alloc &gt;::empty()</a>, <a class="el" href="a00551_source.html#l05407">std::discrete_distribution&lt; _IntType &gt;::max()</a>, <a class="el" href="a00722_source.html#l02035">std::operator==()</a>, <a class="el" href="a00722_source.html#l01008">std::vector&lt; _Tp, _Alloc &gt;::resize()</a>, and <a class="el" href="a00581_source.html#l01821">std::match_results&lt; _Bi_iter, _Alloc &gt;::size()</a>.</p>

</div>
</div>
<a id="a38b09d78602cf28cd1c5dd1c1447c278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b09d78602cf28cd1c5dd1c1447c278">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="a08862.html">std::vector</a>&lt; _Tp, _Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08862.html">vector</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps data with another vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A vector of the same element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>This exchanges the elements between two vectors in constant time. (Three pointers, so it should be quite fast.) Note that the global std::swap() function is specialized such that std::swap(v1,v2) will feed to this function.</p>
<p>Whether the allocators are swapped depends on the allocator traits. </p>

<p class="definition">Definition at line <a class="el" href="a00722_source.html#l01581">1581</a> of file <a class="el" href="a00722_source.html">stl_vector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00581_source.html#l02048">std::match_results&lt; _Bi_iter, _Alloc &gt;::swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00722_source.html">stl_vector.h</a></li>
<li><a class="el" href="a00779_source.html">vector.tcc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a01655.html">std</a></li><li class="navelem"><a class="el" href="a08862.html">vector</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
