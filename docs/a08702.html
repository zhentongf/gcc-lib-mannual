<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstdc++: std::map&lt; _Key, _Tp, _Compare, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a08702.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a08699.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a867cc7a6efcc2cebb289245de03ea425"><td class="memItemLeft" align="right" valign="top"><a id="a867cc7a6efcc2cebb289245de03ea425"></a>
typedef _Alloc&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a867cc7a6efcc2cebb289245de03ea425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1df2bfc685ee54dd54794212339e2a"><td class="memItemLeft" align="right" valign="top"><a id="a9b1df2bfc685ee54dd54794212339e2a"></a>
typedef _Rep_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a9b1df2bfc685ee54dd54794212339e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edaa7002011ed182d4b4dd23cf08ba0"><td class="memItemLeft" align="right" valign="top"><a id="a1edaa7002011ed182d4b4dd23cf08ba0"></a>
typedef _Alloc_traits::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a1edaa7002011ed182d4b4dd23cf08ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e88ad2998d92460ff7f10deae148e1"><td class="memItemLeft" align="right" valign="top"><a id="a32e88ad2998d92460ff7f10deae148e1"></a>
typedef _Alloc_traits::const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a32e88ad2998d92460ff7f10deae148e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1369488bc07cf4e0975a1aa15502653a"><td class="memItemLeft" align="right" valign="top"><a id="a1369488bc07cf4e0975a1aa15502653a"></a>
typedef <a class="el" href="a08518.html">_Rep_type::const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a1369488bc07cf4e0975a1aa15502653a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99226a7763d56c0ac0df6ab70bf55add"><td class="memItemLeft" align="right" valign="top"><a id="a99226a7763d56c0ac0df6ab70bf55add"></a>
typedef _Rep_type::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a99226a7763d56c0ac0df6ab70bf55add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f1c15696f8ca9dfe110939446c315b"><td class="memItemLeft" align="right" valign="top"><a id="aa5f1c15696f8ca9dfe110939446c315b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>insert_return_type</b> = typename <a class="el" href="a06498.html">_Rep_type::insert_return_type</a></td></tr>
<tr class="separator:aa5f1c15696f8ca9dfe110939446c315b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42798b317d174da59f38d1d2aab56b7"><td class="memItemLeft" align="right" valign="top"><a id="ad42798b317d174da59f38d1d2aab56b7"></a>
typedef _Rep_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:ad42798b317d174da59f38d1d2aab56b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe75416285672c7a3db4c173460e8523"><td class="memItemLeft" align="right" valign="top"><a id="afe75416285672c7a3db4c173460e8523"></a>
typedef _Compare&#160;</td><td class="memItemRight" valign="bottom"><b>key_compare</b></td></tr>
<tr class="separator:afe75416285672c7a3db4c173460e8523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87be4bdb1494b4ff6b3a1bb03d4684d9"><td class="memItemLeft" align="right" valign="top"><a id="a87be4bdb1494b4ff6b3a1bb03d4684d9"></a>
typedef _Key&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr class="separator:a87be4bdb1494b4ff6b3a1bb03d4684d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2084dfc3d5b7ef98bdfcfe157638bb"><td class="memItemLeft" align="right" valign="top"><a id="a0e2084dfc3d5b7ef98bdfcfe157638bb"></a>
typedef _Tp&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b></td></tr>
<tr class="separator:a0e2084dfc3d5b7ef98bdfcfe157638bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa022e312594cdd1d3c965763943d2e6f"><td class="memItemLeft" align="right" valign="top"><a id="aa022e312594cdd1d3c965763943d2e6f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>node_type</b> = typename <a class="el" href="a06490.html">_Rep_type::node_type</a></td></tr>
<tr class="separator:aa022e312594cdd1d3c965763943d2e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ff80435ad3db0be7a6071f4fcae60f"><td class="memItemLeft" align="right" valign="top"><a id="ae8ff80435ad3db0be7a6071f4fcae60f"></a>
typedef _Alloc_traits::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:ae8ff80435ad3db0be7a6071f4fcae60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440e91f29aa4c7738f50fa2b5f0e7a27"><td class="memItemLeft" align="right" valign="top"><a id="a440e91f29aa4c7738f50fa2b5f0e7a27"></a>
typedef _Alloc_traits::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a440e91f29aa4c7738f50fa2b5f0e7a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ab8c064375f3eed8e830e24da77db7"><td class="memItemLeft" align="right" valign="top"><a id="ac1ab8c064375f3eed8e830e24da77db7"></a>
typedef <a class="el" href="a08518.html">_Rep_type::reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:ac1ab8c064375f3eed8e830e24da77db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e71ab831bae109a6154e228164308a"><td class="memItemLeft" align="right" valign="top"><a id="a41e71ab831bae109a6154e228164308a"></a>
typedef _Rep_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a41e71ab831bae109a6154e228164308a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f024f046d23ebeb95299033d6669dd"><td class="memItemLeft" align="right" valign="top"><a id="ad5f024f046d23ebeb95299033d6669dd"></a>
typedef <a class="el" href="a08610.html">std::pair</a>&lt; const _Key, _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:ad5f024f046d23ebeb95299033d6669dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc7cdce90f8100d9bf741d33f2b50019"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#afc7cdce90f8100d9bf741d33f2b50019">map</a> ()=default</td></tr>
<tr class="separator:afc7cdce90f8100d9bf741d33f2b50019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6339535802f1937f3dd78ee04d950ea7"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a6339535802f1937f3dd78ee04d950ea7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a6339535802f1937f3dd78ee04d950ea7">map</a> (_InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:a6339535802f1937f3dd78ee04d950ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30882bd54277810ace3d0630cbc3252"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:ac30882bd54277810ace3d0630cbc3252"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#ac30882bd54277810ace3d0630cbc3252">map</a> (_InputIterator __first, _InputIterator __last, const _Compare &amp;__comp, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:ac30882bd54277810ace3d0630cbc3252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2b5c52350b2b79506ab308b32ca5f1"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a0d2b5c52350b2b79506ab308b32ca5f1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a0d2b5c52350b2b79506ab308b32ca5f1">map</a> (_InputIterator __first, _InputIterator __last, const allocator_type &amp;__a)</td></tr>
<tr class="separator:a0d2b5c52350b2b79506ab308b32ca5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12fa7df574ac42da454cba7581c258e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#aa12fa7df574ac42da454cba7581c258e">map</a> (const _Compare &amp;__comp, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:aa12fa7df574ac42da454cba7581c258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d93d27671323c77e27ef2986a4bcb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a97d93d27671323c77e27ef2986a4bcb8">map</a> (const allocator_type &amp;__a)</td></tr>
<tr class="separator:a97d93d27671323c77e27ef2986a4bcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8710ed019be6e93c3e226853e91da124"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a8710ed019be6e93c3e226853e91da124">map</a> (const <a class="el" href="a08702.html">map</a> &amp;)=default</td></tr>
<tr class="separator:a8710ed019be6e93c3e226853e91da124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263cddb5f921b7775b75485269e85fa3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a263cddb5f921b7775b75485269e85fa3">map</a> (const <a class="el" href="a08702.html">map</a> &amp;__m, const __type_identity_t&lt; allocator_type &gt; &amp;__a)</td></tr>
<tr class="separator:a263cddb5f921b7775b75485269e85fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353d38055f6c80e99c699ee4eeec914e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a353d38055f6c80e99c699ee4eeec914e">map</a> (<a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08610.html">value_type</a> &gt; __l, const _Compare &amp;__comp=_Compare(), const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:a353d38055f6c80e99c699ee4eeec914e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8310f2293e381afba51e9cc44dd0eeef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a8310f2293e381afba51e9cc44dd0eeef">map</a> (<a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08610.html">value_type</a> &gt; __l, const allocator_type &amp;__a)</td></tr>
<tr class="separator:a8310f2293e381afba51e9cc44dd0eeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f71fbbe2f15bf4a55f383030fe7d72f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a3f71fbbe2f15bf4a55f383030fe7d72f">map</a> (<a class="el" href="a08702.html">map</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a3f71fbbe2f15bf4a55f383030fe7d72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b87ad2ef04017a2709af89de41f820f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a5b87ad2ef04017a2709af89de41f820f">map</a> (<a class="el" href="a08702.html">map</a> &amp;&amp;__m, const __type_identity_t&lt; allocator_type &gt; &amp;__a) noexcept(<a class="el" href="a04042.html">is_nothrow_copy_constructible</a>&lt; _Compare &gt;::value &amp;&amp;_Alloc_traits::_S_always_equal())</td></tr>
<tr class="separator:a5b87ad2ef04017a2709af89de41f820f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2460e7e43dc674a1cb696c4eb1985b5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a2460e7e43dc674a1cb696c4eb1985b5e">~map</a> ()=default</td></tr>
<tr class="separator:a2460e7e43dc674a1cb696c4eb1985b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4942bb42ef39ce49cc232c06416f55"><td class="memItemLeft" align="right" valign="top">mapped_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#aaf4942bb42ef39ce49cc232c06416f55">at</a> (const key_type &amp;__k)</td></tr>
<tr class="separator:aaf4942bb42ef39ce49cc232c06416f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f33f76669f25895f52d3518f8685461"><td class="memItemLeft" align="right" valign="top"><a id="a6f33f76669f25895f52d3518f8685461"></a>
const mapped_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (const key_type &amp;__k) const</td></tr>
<tr class="separator:a6f33f76669f25895f52d3518f8685461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ca23264de805bde6259ab11c9d93c"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#af46ca23264de805bde6259ab11c9d93c">begin</a> () const noexcept</td></tr>
<tr class="separator:af46ca23264de805bde6259ab11c9d93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af515aec447786d3fcfff02fe18385cbc"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#af515aec447786d3fcfff02fe18385cbc">begin</a> () noexcept</td></tr>
<tr class="separator:af515aec447786d3fcfff02fe18385cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11167910bc728cbeb7997b7e8bd8326"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#af11167910bc728cbeb7997b7e8bd8326">cbegin</a> () const noexcept</td></tr>
<tr class="separator:af11167910bc728cbeb7997b7e8bd8326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512508ab8aef5dad73ae92751513769e"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a512508ab8aef5dad73ae92751513769e">cend</a> () const noexcept</td></tr>
<tr class="separator:a512508ab8aef5dad73ae92751513769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c72b2772d31bff52f9454a583547f58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a5c72b2772d31bff52f9454a583547f58">clear</a> () noexcept</td></tr>
<tr class="separator:a5c72b2772d31bff52f9454a583547f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68296cab04aadacb8da0b4bb1a8d8991"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08518.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a68296cab04aadacb8da0b4bb1a8d8991">crbegin</a> () const noexcept</td></tr>
<tr class="separator:a68296cab04aadacb8da0b4bb1a8d8991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd5c263f187f16ca9f073e1789a02ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08518.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#adbd5c263f187f16ca9f073e1789a02ff">crend</a> () const noexcept</td></tr>
<tr class="separator:adbd5c263f187f16ca9f073e1789a02ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdeb769358f26cc1f0124f5c53df0eb"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:adbdeb769358f26cc1f0124f5c53df0eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08610.html">std::pair</a>&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#adbdeb769358f26cc1f0124f5c53df0eb">emplace</a> (_Args &amp;&amp;... __args)</td></tr>
<tr class="separator:adbdeb769358f26cc1f0124f5c53df0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e3c11364a0f9f6304581d1dc69bd34"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a01e3c11364a0f9f6304581d1dc69bd34"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a01e3c11364a0f9f6304581d1dc69bd34">emplace_hint</a> (const_iterator __pos, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a01e3c11364a0f9f6304581d1dc69bd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16986a6517197b25e8ad3f7487c8536f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a16986a6517197b25e8ad3f7487c8536f">empty</a> () const noexcept</td></tr>
<tr class="separator:a16986a6517197b25e8ad3f7487c8536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d3bee624167086813c84cc5fbc0f8f"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a50d3bee624167086813c84cc5fbc0f8f">end</a> () const noexcept</td></tr>
<tr class="separator:a50d3bee624167086813c84cc5fbc0f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfaf89a89106d147fd055c313a291ee"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a5dfaf89a89106d147fd055c313a291ee">end</a> () noexcept</td></tr>
<tr class="separator:a5dfaf89a89106d147fd055c313a291ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b510fc380b070d899d73a278cbb8faf"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a6b510fc380b070d899d73a278cbb8faf">erase</a> (const key_type &amp;__x)</td></tr>
<tr class="separator:a6b510fc380b070d899d73a278cbb8faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98a4bd34df51b51262b26f06a657efe"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#aa98a4bd34df51b51262b26f06a657efe">erase</a> (const_iterator __first, const_iterator __last)</td></tr>
<tr class="separator:aa98a4bd34df51b51262b26f06a657efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999812d7c30caadb58cf5beecea28fa9"><td class="memItemLeft" align="right" valign="top">node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a999812d7c30caadb58cf5beecea28fa9">extract</a> (const key_type &amp;__x)</td></tr>
<tr class="separator:a999812d7c30caadb58cf5beecea28fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0e0fd8f88724733e12cdd9f78b00d7"><td class="memItemLeft" align="right" valign="top">node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a8d0e0fd8f88724733e12cdd9f78b00d7">extract</a> (const_iterator __pos)</td></tr>
<tr class="separator:a8d0e0fd8f88724733e12cdd9f78b00d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc72d6a2972834a9f512d424310468a7"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#adc72d6a2972834a9f512d424310468a7">get_allocator</a> () const noexcept</td></tr>
<tr class="separator:adc72d6a2972834a9f512d424310468a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3186e7576e4ffc474fd92f66e460d231"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a3186e7576e4ffc474fd92f66e460d231"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a3186e7576e4ffc474fd92f66e460d231">insert</a> (_InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:a3186e7576e4ffc474fd92f66e460d231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754f1efe2731112bcb8208d177623445"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a754f1efe2731112bcb8208d177623445">insert</a> (const_iterator __hint, node_type &amp;&amp;__nh)</td></tr>
<tr class="separator:a754f1efe2731112bcb8208d177623445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ab2a881fab728dacf8db3253497851"><td class="memItemLeft" align="right" valign="top">insert_return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a35ab2a881fab728dacf8db3253497851">insert</a> (node_type &amp;&amp;__nh)</td></tr>
<tr class="separator:a35ab2a881fab728dacf8db3253497851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab228710aaa8c81fc3b7fe37b26fc709a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#ab228710aaa8c81fc3b7fe37b26fc709a">insert</a> (<a class="el" href="a01878.html">std::initializer_list</a>&lt; <a class="el" href="a08610.html">value_type</a> &gt; __list)</td></tr>
<tr class="separator:ab228710aaa8c81fc3b7fe37b26fc709a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252f2554cf85af68c52a8413ef6bd981"><td class="memTemplParams" colspan="2">template&lt;typename _Obj &gt; </td></tr>
<tr class="memitem:a252f2554cf85af68c52a8413ef6bd981"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08610.html">pair</a>&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a252f2554cf85af68c52a8413ef6bd981">insert_or_assign</a> (const key_type &amp;__k, _Obj &amp;&amp;__obj)</td></tr>
<tr class="separator:a252f2554cf85af68c52a8413ef6bd981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b126919b98ad8e8dc76d44bad98280"><td class="memTemplParams" colspan="2">template&lt;typename _Obj &gt; </td></tr>
<tr class="memitem:a50b126919b98ad8e8dc76d44bad98280"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a50b126919b98ad8e8dc76d44bad98280">insert_or_assign</a> (const_iterator __hint, const key_type &amp;__k, _Obj &amp;&amp;__obj)</td></tr>
<tr class="separator:a50b126919b98ad8e8dc76d44bad98280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5733084e601ada8c57751e25d55e9ed8"><td class="memTemplParams" colspan="2"><a id="a5733084e601ada8c57751e25d55e9ed8"></a>
template&lt;typename _Obj &gt; </td></tr>
<tr class="memitem:a5733084e601ada8c57751e25d55e9ed8"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (const_iterator __hint, key_type &amp;&amp;__k, _Obj &amp;&amp;__obj)</td></tr>
<tr class="separator:a5733084e601ada8c57751e25d55e9ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030ab3067fcc7943a4dfc954b2bbe039"><td class="memTemplParams" colspan="2"><a id="a030ab3067fcc7943a4dfc954b2bbe039"></a>
template&lt;typename _Obj &gt; </td></tr>
<tr class="memitem:a030ab3067fcc7943a4dfc954b2bbe039"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08610.html">pair</a>&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (key_type &amp;&amp;__k, _Obj &amp;&amp;__obj)</td></tr>
<tr class="separator:a030ab3067fcc7943a4dfc954b2bbe039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59af09cf176afb26d8e2657581429d3f"><td class="memItemLeft" align="right" valign="top">key_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a59af09cf176afb26d8e2657581429d3f">key_comp</a> () const</td></tr>
<tr class="separator:a59af09cf176afb26d8e2657581429d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c022c3b246d7beb4c6eae4d6ce7ca2"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#af2c022c3b246d7beb4c6eae4d6ce7ca2">max_size</a> () const noexcept</td></tr>
<tr class="separator:af2c022c3b246d7beb4c6eae4d6ce7ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d480ff56e398a50181a4784ef5ce5a"><td class="memTemplParams" colspan="2"><a id="a24d480ff56e398a50181a4784ef5ce5a"></a>
template&lt;typename _Cmp2 &gt; </td></tr>
<tr class="memitem:a24d480ff56e398a50181a4784ef5ce5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>merge</b> (<a class="el" href="a08702.html">map</a>&lt; _Key, _Tp, _Cmp2, _Alloc &gt; &amp;&amp;__source)</td></tr>
<tr class="separator:a24d480ff56e398a50181a4784ef5ce5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb38eb9dc1ef1fbc568e25568661222e"><td class="memTemplParams" colspan="2"><a id="afb38eb9dc1ef1fbc568e25568661222e"></a>
template&lt;typename _Cmp2 &gt; </td></tr>
<tr class="memitem:afb38eb9dc1ef1fbc568e25568661222e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>merge</b> (<a class="el" href="a08702.html">map</a>&lt; _Key, _Tp, _Cmp2, _Alloc &gt; &amp;__source)</td></tr>
<tr class="separator:afb38eb9dc1ef1fbc568e25568661222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffa6454182bfb28ea7eed8e5f6baa36"><td class="memTemplParams" colspan="2"><a id="afffa6454182bfb28ea7eed8e5f6baa36"></a>
template&lt;typename _Cmp2 &gt; </td></tr>
<tr class="memitem:afffa6454182bfb28ea7eed8e5f6baa36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>merge</b> (<a class="el" href="a08698.html">multimap</a>&lt; _Key, _Tp, _Cmp2, _Alloc &gt; &amp;&amp;__source)</td></tr>
<tr class="separator:afffa6454182bfb28ea7eed8e5f6baa36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d67201ed993f29b8c705d26fb36c73"><td class="memTemplParams" colspan="2"><a id="aa0d67201ed993f29b8c705d26fb36c73"></a>
template&lt;typename _Cmp2 &gt; </td></tr>
<tr class="memitem:aa0d67201ed993f29b8c705d26fb36c73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>merge</b> (<a class="el" href="a08698.html">multimap</a>&lt; _Key, _Tp, _Cmp2, _Alloc &gt; &amp;__source)</td></tr>
<tr class="separator:aa0d67201ed993f29b8c705d26fb36c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffbbf85c084d61ab49c7fec028bafba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08702.html">map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a0ffbbf85c084d61ab49c7fec028bafba">operator=</a> (const <a class="el" href="a08702.html">map</a> &amp;)=default</td></tr>
<tr class="separator:a0ffbbf85c084d61ab49c7fec028bafba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01f44f3ed4b9dbebcb046b4103f920c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08702.html">map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#ac01f44f3ed4b9dbebcb046b4103f920c">operator=</a> (<a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08610.html">value_type</a> &gt; __l)</td></tr>
<tr class="separator:ac01f44f3ed4b9dbebcb046b4103f920c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b4c4feee2bbdf398540f4097d4bb91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08702.html">map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a28b4c4feee2bbdf398540f4097d4bb91">operator=</a> (<a class="el" href="a08702.html">map</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a28b4c4feee2bbdf398540f4097d4bb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4a9f95131baf0713596d672ec36b5f"><td class="memItemLeft" align="right" valign="top">mapped_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a4a4a9f95131baf0713596d672ec36b5f">operator[]</a> (const key_type &amp;__k)</td></tr>
<tr class="separator:a4a4a9f95131baf0713596d672ec36b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cdcf12be689d224f2e31ccfff4f3af"><td class="memItemLeft" align="right" valign="top"><a id="a14cdcf12be689d224f2e31ccfff4f3af"></a>
mapped_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (key_type &amp;&amp;__k)</td></tr>
<tr class="separator:a14cdcf12be689d224f2e31ccfff4f3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461fb30e5fd8953549843ff651d06ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08518.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a461fb30e5fd8953549843ff651d06ec8">rbegin</a> () const noexcept</td></tr>
<tr class="separator:a461fb30e5fd8953549843ff651d06ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca3db2d238641b23001310899d884fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08518.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a4ca3db2d238641b23001310899d884fb">rbegin</a> () noexcept</td></tr>
<tr class="separator:a4ca3db2d238641b23001310899d884fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21512c1e39cedc32e0275f89f888d4aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08518.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a21512c1e39cedc32e0275f89f888d4aa">rend</a> () const noexcept</td></tr>
<tr class="separator:a21512c1e39cedc32e0275f89f888d4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa467231586b6bc6388765ec6802aef54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08518.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#aa467231586b6bc6388765ec6802aef54">rend</a> () noexcept</td></tr>
<tr class="separator:aa467231586b6bc6388765ec6802aef54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dd27409135bbee5bb626cd72e0cddb"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#ab8dd27409135bbee5bb626cd72e0cddb">size</a> () const noexcept</td></tr>
<tr class="separator:ab8dd27409135bbee5bb626cd72e0cddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab3829e42e61a94d9039fea4c07b62f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a6ab3829e42e61a94d9039fea4c07b62f">swap</a> (<a class="el" href="a08702.html">map</a> &amp;__x) noexcept(/*<a class="el" href="a04458.html">conditional</a> */)</td></tr>
<tr class="separator:a6ab3829e42e61a94d9039fea4c07b62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841a686dcb65f3031dff39d54dbbc0c2"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a841a686dcb65f3031dff39d54dbbc0c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08610.html">pair</a>&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a841a686dcb65f3031dff39d54dbbc0c2">try_emplace</a> (const key_type &amp;__k, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a841a686dcb65f3031dff39d54dbbc0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a87dbbec2f949e278c1fd1834aa8a4"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a39a87dbbec2f949e278c1fd1834aa8a4"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a39a87dbbec2f949e278c1fd1834aa8a4">try_emplace</a> (const_iterator __hint, const key_type &amp;__k, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a39a87dbbec2f949e278c1fd1834aa8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1430d4e3281fa9bd1eee24f99833f8e5"><td class="memTemplParams" colspan="2"><a id="a1430d4e3281fa9bd1eee24f99833f8e5"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a1430d4e3281fa9bd1eee24f99833f8e5"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace</b> (const_iterator __hint, key_type &amp;&amp;__k, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a1430d4e3281fa9bd1eee24f99833f8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2757a5eeebf5646d61f613d0ada4ae66"><td class="memTemplParams" colspan="2"><a id="a2757a5eeebf5646d61f613d0ada4ae66"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a2757a5eeebf5646d61f613d0ada4ae66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08610.html">pair</a>&lt; iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace</b> (key_type &amp;&amp;__k, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a2757a5eeebf5646d61f613d0ada4ae66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c51f439c6328b72ebdd7e5e558ef847"><td class="memItemLeft" align="right" valign="top">value_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a2c51f439c6328b72ebdd7e5e558ef847">value_comp</a> () const</td></tr>
<tr class="separator:a2c51f439c6328b72ebdd7e5e558ef847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3a5341d2ce3f2ffa4426d29110ca8e41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08610.html">std::pair</a>&lt; iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a3a5341d2ce3f2ffa4426d29110ca8e41">insert</a> (const <a class="el" href="a08610.html">value_type</a> &amp;__x)</td></tr>
<tr class="separator:a3a5341d2ce3f2ffa4426d29110ca8e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b8084648ff490a86c7cf951f537a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08610.html">std::pair</a>&lt; iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a94b8084648ff490a86c7cf951f537a37">insert</a> (<a class="el" href="a08610.html">value_type</a> &amp;&amp;__x)</td></tr>
<tr class="separator:a94b8084648ff490a86c7cf951f537a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95452a6c3677b7176b6b8e3d24e9176"><td class="memTemplParams" colspan="2">template&lt;typename _Pair &gt; </td></tr>
<tr class="memitem:ad95452a6c3677b7176b6b8e3d24e9176"><td class="memTemplItemLeft" align="right" valign="top">__enable_if_t&lt; <a class="el" href="a04018.html">is_constructible</a>&lt; <a class="el" href="a08610.html">value_type</a>, _Pair &gt;::value, <a class="el" href="a08610.html">pair</a>&lt; iterator, bool &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#ad95452a6c3677b7176b6b8e3d24e9176">insert</a> (_Pair &amp;&amp;__x)</td></tr>
<tr class="separator:ad95452a6c3677b7176b6b8e3d24e9176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa0d825fbc11a62dc06420646e0c90dd5"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#aa0d825fbc11a62dc06420646e0c90dd5">insert</a> (const_iterator __position, const <a class="el" href="a08610.html">value_type</a> &amp;__x)</td></tr>
<tr class="separator:aa0d825fbc11a62dc06420646e0c90dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ddc0c2cfe1d8a8cac10a2b59207c68"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a99ddc0c2cfe1d8a8cac10a2b59207c68">insert</a> (const_iterator __position, <a class="el" href="a08610.html">value_type</a> &amp;&amp;__x)</td></tr>
<tr class="separator:a99ddc0c2cfe1d8a8cac10a2b59207c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9296f57a3c7c517446504a256dcc48de"><td class="memTemplParams" colspan="2">template&lt;typename _Pair &gt; </td></tr>
<tr class="memitem:a9296f57a3c7c517446504a256dcc48de"><td class="memTemplItemLeft" align="right" valign="top">__enable_if_t&lt; <a class="el" href="a04018.html">is_constructible</a>&lt; <a class="el" href="a08610.html">value_type</a>, _Pair &gt;::value, iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a9296f57a3c7c517446504a256dcc48de">insert</a> (const_iterator __position, _Pair &amp;&amp;__x)</td></tr>
<tr class="separator:a9296f57a3c7c517446504a256dcc48de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac9ea51e48199ff9a87ea1b855789e53d"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#ac9ea51e48199ff9a87ea1b855789e53d">erase</a> (const_iterator __position)</td></tr>
<tr class="separator:ac9ea51e48199ff9a87ea1b855789e53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60f51e27db51a169ee4e368d238f69e"><td class="memItemLeft" align="right" valign="top">_GLIBCXX_ABI_TAG_CXX11 iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#ae60f51e27db51a169ee4e368d238f69e">erase</a> (iterator __position)</td></tr>
<tr class="separator:ae60f51e27db51a169ee4e368d238f69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abdcd985632d8ad7ddba069aa776e2dfe"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#abdcd985632d8ad7ddba069aa776e2dfe">find</a> (const key_type &amp;__x)</td></tr>
<tr class="separator:abdcd985632d8ad7ddba069aa776e2dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39303b5617b240f3049dbb0d195789f5"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:a39303b5617b240f3049dbb0d195789f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a39303b5617b240f3049dbb0d195789f5">find</a> (const _Kt &amp;__x) -&gt; decltype(_M_t._M_find_tr(__x))</td></tr>
<tr class="separator:a39303b5617b240f3049dbb0d195789f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a07cdb0ebaf753ec1244849dbff2ec4cf"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a07cdb0ebaf753ec1244849dbff2ec4cf">find</a> (const key_type &amp;__x) const</td></tr>
<tr class="separator:a07cdb0ebaf753ec1244849dbff2ec4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf5f3477b6615f6b31fcb1adf068dfc"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:accf5f3477b6615f6b31fcb1adf068dfc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#accf5f3477b6615f6b31fcb1adf068dfc">find</a> (const _Kt &amp;__x) const -&gt; decltype(_M_t._M_find_tr(__x))</td></tr>
<tr class="separator:accf5f3477b6615f6b31fcb1adf068dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a44da6d0dc51d80a873cc9405a805c712"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a44da6d0dc51d80a873cc9405a805c712">count</a> (const key_type &amp;__x) const</td></tr>
<tr class="separator:a44da6d0dc51d80a873cc9405a805c712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1264d32ee2fd0cfaee914fbafc088b54"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:a1264d32ee2fd0cfaee914fbafc088b54"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a1264d32ee2fd0cfaee914fbafc088b54">count</a> (const _Kt &amp;__x) const -&gt; decltype(_M_t._M_count_tr(__x))</td></tr>
<tr class="separator:a1264d32ee2fd0cfaee914fbafc088b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a23e2c9dd542c15b69115937680d5161a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a23e2c9dd542c15b69115937680d5161a">contains</a> (const key_type &amp;__x) const</td></tr>
<tr class="separator:a23e2c9dd542c15b69115937680d5161a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec2e27fbf16a7ab2bbd7db5487d209f"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:acec2e27fbf16a7ab2bbd7db5487d209f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#acec2e27fbf16a7ab2bbd7db5487d209f">contains</a> (const _Kt &amp;__x) const -&gt; decltype(_M_t._M_find_tr(__x), void(), true)</td></tr>
<tr class="separator:acec2e27fbf16a7ab2bbd7db5487d209f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adbb7e90f8d6bece7f9ffb6b76c9ab081"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#adbb7e90f8d6bece7f9ffb6b76c9ab081">lower_bound</a> (const key_type &amp;__x)</td></tr>
<tr class="separator:adbb7e90f8d6bece7f9ffb6b76c9ab081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db81ee7912a625e5d7ead27f0cb4133"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:a5db81ee7912a625e5d7ead27f0cb4133"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a5db81ee7912a625e5d7ead27f0cb4133">lower_bound</a> (const _Kt &amp;__x) -&gt; decltype(iterator(_M_t._M_lower_bound_tr(__x)))</td></tr>
<tr class="separator:a5db81ee7912a625e5d7ead27f0cb4133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab801bf5b252cc1b28af052263ce33d7a"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#ab801bf5b252cc1b28af052263ce33d7a">lower_bound</a> (const key_type &amp;__x) const</td></tr>
<tr class="separator:ab801bf5b252cc1b28af052263ce33d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfc6f822052135a0b48e0dca314ccaf"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:a2dfc6f822052135a0b48e0dca314ccaf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a2dfc6f822052135a0b48e0dca314ccaf">lower_bound</a> (const _Kt &amp;__x) const -&gt; decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))</td></tr>
<tr class="separator:a2dfc6f822052135a0b48e0dca314ccaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a31f6ba9ed7f80198dd444d6d830a3c80"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a31f6ba9ed7f80198dd444d6d830a3c80">upper_bound</a> (const key_type &amp;__x)</td></tr>
<tr class="separator:a31f6ba9ed7f80198dd444d6d830a3c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dfea28ca363de5083ec265382de319"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:a58dfea28ca363de5083ec265382de319"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a58dfea28ca363de5083ec265382de319">upper_bound</a> (const _Kt &amp;__x) -&gt; decltype(iterator(_M_t._M_upper_bound_tr(__x)))</td></tr>
<tr class="separator:a58dfea28ca363de5083ec265382de319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afd9ba5f5b31a79317b1c5ec547b9ec6c"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#afd9ba5f5b31a79317b1c5ec547b9ec6c">upper_bound</a> (const key_type &amp;__x) const</td></tr>
<tr class="separator:afd9ba5f5b31a79317b1c5ec547b9ec6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9ce0ad35c587805de6a54c3e61cd02"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:abd9ce0ad35c587805de6a54c3e61cd02"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#abd9ce0ad35c587805de6a54c3e61cd02">upper_bound</a> (const _Kt &amp;__x) const -&gt; decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))</td></tr>
<tr class="separator:abd9ce0ad35c587805de6a54c3e61cd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5e0d4434a099805754b757634f18cc23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08610.html">std::pair</a>&lt; iterator, iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#a5e0d4434a099805754b757634f18cc23">equal_range</a> (const key_type &amp;__x)</td></tr>
<tr class="separator:a5e0d4434a099805754b757634f18cc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae814e0a8ac259c3119c95716748f7819"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:ae814e0a8ac259c3119c95716748f7819"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#ae814e0a8ac259c3119c95716748f7819">equal_range</a> (const _Kt &amp;__x) -&gt; decltype(<a class="el" href="a08610.html">pair</a>&lt; iterator, iterator &gt;(_M_t._M_equal_range_tr(__x)))</td></tr>
<tr class="separator:ae814e0a8ac259c3119c95716748f7819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad849929336a71e065e43fdf6a294140e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08610.html">std::pair</a>&lt; const_iterator, const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08702.html#ad849929336a71e065e43fdf6a294140e">equal_range</a> (const key_type &amp;__x) const</td></tr>
<tr class="separator:ad849929336a71e065e43fdf6a294140e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e9a1f958274d603fe083a7b9f50558"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:a14e9a1f958274d603fe083a7b9f50558"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08702.html#a14e9a1f958274d603fe083a7b9f50558">equal_range</a> (const _Kt &amp;__x) const -&gt; decltype(<a class="el" href="a08610.html">pair</a>&lt; const_iterator, const_iterator &gt;(_M_t._M_equal_range_tr(__x)))</td></tr>
<tr class="separator:a14e9a1f958274d603fe083a7b9f50558"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a00451026c0ad74c0de0c2118f23964ba"><td class="memTemplParams" colspan="2"><a id="a00451026c0ad74c0de0c2118f23964ba"></a>
template&lt;typename _K1 , typename _T1 , typename _C1 , typename _A1 &gt; </td></tr>
<tr class="memitem:a00451026c0ad74c0de0c2118f23964ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="a08702.html">map</a>&lt; _K1, _T1, _C1, _A1 &gt; &amp;, const <a class="el" href="a08702.html">map</a>&lt; _K1, _T1, _C1, _A1 &gt; &amp;)</td></tr>
<tr class="separator:a00451026c0ad74c0de0c2118f23964ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f842d5d0a0a84e01fcc406ca18ce72"><td class="memTemplParams" colspan="2"><a id="a05f842d5d0a0a84e01fcc406ca18ce72"></a>
template&lt;typename _K1 , typename _T1 , typename _C1 , typename _A1 &gt; </td></tr>
<tr class="memitem:a05f842d5d0a0a84e01fcc406ca18ce72"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a08702.html">map</a>&lt; _K1, _T1, _C1, _A1 &gt; &amp;, const <a class="el" href="a08702.html">map</a>&lt; _K1, _T1, _C1, _A1 &gt; &amp;)</td></tr>
<tr class="separator:a05f842d5d0a0a84e01fcc406ca18ce72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc9b6708f076443f362f0d901ff5549"><td class="memTemplParams" colspan="2"><a id="a0bc9b6708f076443f362f0d901ff5549"></a>
template&lt;typename , typename &gt; </td></tr>
<tr class="memitem:a0bc9b6708f076443f362f0d901ff5549"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::_Rb_tree_merge_helper</b></td></tr>
<tr class="separator:a0bc9b6708f076443f362f0d901ff5549"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Key, typename _Tp, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;<br />
class std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;</h3>

<p>A standard container made up of (key,value) pairs, which can be retrieved based on a key, in logarithmic time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Key</td><td>Type of key objects. </td></tr>
    <tr><td class="paramname">_Tp</td><td>Type of mapped objects. </td></tr>
    <tr><td class="paramname">_Compare</td><td>Comparison function object type, defaults to less&lt;_Key&gt;. </td></tr>
    <tr><td class="paramname">_Alloc</td><td>Allocator type, defaults to allocator&lt;pair&lt;const _Key, _Tp&gt;.</td></tr>
  </table>
  </dd>
</dl>
<p>Meets the requirements of a <a href="tables.html#65">container</a>, a <a href="tables.html#66">reversible container</a>, and an <a href="tables.html#69">associative container</a> (using unique keys). For a <code>map&lt;Key,T&gt;</code> the key_type is Key, the mapped_type is T, and the value_type is std::pair&lt;const Key,T&gt;.</p>
<p>Maps support bidirectional iterators.</p>
<p>The private tree data is declared exactly the same way for map and multimap; the distinction is made entirely in how the tree functions are called (*_unique versus *_equal, same as the standard). </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00100">100</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afc7cdce90f8100d9bf741d33f2b50019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7cdce90f8100d9bf741d33f2b50019">&#9670;&nbsp;</a></span>map() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor creates no elements. </p>

</div>
</div>
<a id="aa12fa7df574ac42da454cba7581c258e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12fa7df574ac42da454cba7581c258e">&#9670;&nbsp;</a></span>map() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">const _Compare &amp;&#160;</td>
          <td class="paramname"><em>__comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a map with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__comp</td><td>A comparison object. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00204">204</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a8710ed019be6e93c3e226853e91da124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8710ed019be6e93c3e226853e91da124">&#9670;&nbsp;</a></span>map() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08702.html">map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map copy constructor. </p>
<p>Whether the allocator is copied depends on the allocator traits. </p>

</div>
</div>
<a id="a3f71fbbe2f15bf4a55f383030fe7d72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f71fbbe2f15bf4a55f383030fe7d72f">&#9670;&nbsp;</a></span>map() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08702.html">map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map move constructor. </p>
<p>The newly-created map contains the exact contents of the moved instance. The moved instance is a valid, but unspecified, map. </p>

</div>
</div>
<a id="a353d38055f6c80e99c699ee4eeec914e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353d38055f6c80e99c699ee4eeec914e">&#9670;&nbsp;</a></span>map() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08610.html">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Compare &amp;&#160;</td>
          <td class="paramname"><em>__comp</em> = <code>_Compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a map from an initializer_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison object. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a map consisting of copies of the elements in the initializer_list <em>__l</em>. This is linear in N if the range is already sorted, and NlogN otherwise (where N is <em>__l.size()</em>). </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00238">238</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a97d93d27671323c77e27ef2986a4bcb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d93d27671323c77e27ef2986a4bcb8">&#9670;&nbsp;</a></span>map() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended default constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00246">246</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a263cddb5f921b7775b75485269e85fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263cddb5f921b7775b75485269e85fa3">&#9670;&nbsp;</a></span>map() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08702.html">map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const __type_identity_t&lt; allocator_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended copy constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00250">250</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a5b87ad2ef04017a2709af89de41f820f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b87ad2ef04017a2709af89de41f820f">&#9670;&nbsp;</a></span>map() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08702.html">map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const __type_identity_t&lt; allocator_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00254">254</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a8310f2293e381afba51e9cc44dd0eeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8310f2293e381afba51e9cc44dd0eeef">&#9670;&nbsp;</a></span>map() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08610.html">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended initialier-list constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00260">260</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a0d2b5c52350b2b79506ab308b32ca5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2b5c52350b2b79506ab308b32ca5f1">&#9670;&nbsp;</a></span>map() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended range constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00266">266</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a6339535802f1937f3dd78ee04d950ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6339535802f1937f3dd78ee04d950ea7">&#9670;&nbsp;</a></span>map() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a map from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a map consisting of copies of the elements from [__first,__last). This is linear in N if the range is already sorted, and NlogN otherwise (where N is distance(__first,__last)). </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00283">283</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="ac30882bd54277810ace3d0630cbc3252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30882bd54277810ace3d0630cbc3252">&#9670;&nbsp;</a></span>map() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Compare &amp;&#160;</td>
          <td class="paramname"><em>__comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a map from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a map consisting of copies of the elements from [__first,__last). This is linear in N if the range is already sorted, and NlogN otherwise (where N is distance(__first,__last)). </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00300">300</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a2460e7e43dc674a1cb696c4eb1985b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2460e7e43dc674a1cb696c4eb1985b5e">&#9670;&nbsp;</a></span>~map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::~<a class="el" href="a08702.html">map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaf4942bb42ef39ce49cc232c06416f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4942bb42ef39ce49cc232c06416f55">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mapped_type&amp; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to map data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__k</td><td>The key for which data should be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the data whose key is equivalent to <em>__k</em>, if such a data is present in the map. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If no such data is present. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00547">547</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00683_source.html#l00384">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::end()</a>, <a class="el" href="a00683_source.html#l01190">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::key_comp()</a>, and <a class="el" href="a00683_source.html#l01306">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::lower_bound()</a>.</p>

</div>
</div>
<a id="af46ca23264de805bde6259ab11c9d93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46ca23264de805bde6259ab11c9d93c">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first pair in the map. Iteration is done in ascending order according to the keys. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00375">375</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="af515aec447786d3fcfff02fe18385cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af515aec447786d3fcfff02fe18385cbc">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points to the first pair in the map. Iteration is done in ascending order according to the keys. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00366">366</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="af11167910bc728cbeb7997b7e8bd8326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11167910bc728cbeb7997b7e8bd8326">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first pair in the map. Iteration is done in ascending order according to the keys. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00439">439</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a512508ab8aef5dad73ae92751513769e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512508ab8aef5dad73ae92751513769e">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last pair in the map. Iteration is done in ascending order according to the keys. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00448">448</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a5c72b2772d31bff52f9454a583547f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c72b2772d31bff52f9454a583547f58">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all elements in a map. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01181">1181</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="acec2e27fbf16a7ab2bbd7db5487d209f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec2e27fbf16a7ab2bbd7db5487d209f">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; decltype(_M_t._M_find_tr(__x), void(), true)
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds whether an element with the given key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pairs to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is an element with the specified key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01287">1287</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a23e2c9dd542c15b69115937680d5161a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e2c9dd542c15b69115937680d5161a">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds whether an element with the given key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pairs to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is an element with the specified key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01282">1282</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a1264d32ee2fd0cfaee914fbafc088b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1264d32ee2fd0cfaee914fbafc088b54">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; decltype(_M_t._M_count_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of elements with given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pairs to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with specified key.</dd></dl>
<p>This function only makes sense for multimaps; for map the result will either be 0 (not present) or 1 (present). </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01269">1269</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a44da6d0dc51d80a873cc9405a805c712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44da6d0dc51d80a873cc9405a805c712">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of elements with given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pairs to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with specified key.</dd></dl>
<p>This function only makes sense for multimaps; for map the result will either be 0 (not present) or 1 (present). </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01263">1263</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a68296cab04aadacb8da0b4bb1a8d8991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68296cab04aadacb8da0b4bb1a8d8991">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08518.html">const_reverse_iterator</a> <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to the last pair in the map. Iteration is done in descending order according to the keys. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00457">457</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="adbd5c263f187f16ca9f073e1789a02ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd5c263f187f16ca9f073e1789a02ff">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08518.html">const_reverse_iterator</a> <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to one before the first pair in the map. Iteration is done in descending order according to the keys. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00466">466</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="adbdeb769358f26cc1f0124f5c53df0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdeb769358f26cc1f0124f5c53df0eb">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">std::pair</a>&lt;iterator, bool&gt; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to build and insert a std::pair into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__args</td><td>Arguments used to generate a new pair instance (see std::piecewise_contruct for passing arguments to each part of the pair constructor).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</dd></dl>
<p>This function attempts to build and insert a (key, value) pair into the map. A map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the map.</p>
<p>Insertion requires logarithmic time. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00586">586</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a01e3c11364a0f9f6304581d1dc69bd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e3c11364a0f9f6304581d1dc69bd34">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to build and insert a std::pair into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments used to generate a new pair instance (see std::piecewise_contruct for passing arguments to each part of the pair constructor). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of the std::pair built from <em>__args</em> (may or may not be that std::pair).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument emplace() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires logarithmic time (if the hint is not taken). </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00636">636</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00683_source.html#l00846">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert()</a>, <a class="el" href="a00683_source.html#l00966">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert_or_assign()</a>, and <a class="el" href="a00683_source.html#l00721">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::try_emplace()</a>.</p>

</div>
</div>
<a id="a16986a6517197b25e8ad3f7487c8536f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16986a6517197b25e8ad3f7487c8536f">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the map is empty. (Thus begin() would equal end().) </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00475">475</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a50d3bee624167086813c84cc5fbc0f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d3bee624167086813c84cc5fbc0f8f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last pair in the map. Iteration is done in ascending order according to the keys. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00393">393</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a5dfaf89a89106d147fd055c313a291ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfaf89a89106d147fd055c313a291ee">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points one past the last pair in the map. Iteration is done in ascending order according to the keys. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00384">384</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00683_source.html#l00547">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::at()</a>, <a class="el" href="a00683_source.html#l00846">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert()</a>, <a class="el" href="a00683_source.html#l00966">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert_or_assign()</a>, and <a class="el" href="a00683_source.html#l00721">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::try_emplace()</a>.</p>

</div>
</div>
<a id="ae814e0a8ac259c3119c95716748f7819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae814e0a8ac259c3119c95716748f7819">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="a08610.html">pair</a>&lt;iterator, iterator&gt;(_M_t._M_equal_range_tr(__x)))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pairs to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function is equivalent to </p><div class="fragment"><div class="line">std::make_pair(c.lower_bound(val),</div>
<div class="line">               c.upper_bound(val))</div>
</div><!-- fragment --><p> (but is faster than making the calls separately).</p>
<p>This function probably only makes sense for multimaps. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01406">1406</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a14e9a1f958274d603fe083a7b9f50558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e9a1f958274d603fe083a7b9f50558">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; decltype(<a class="el" href="a08610.html">pair</a>&lt;const_iterator, const_iterator&gt;(
	      _M_t._M_equal_range_tr(__x)))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pairs to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of read-only (constant) iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function is equivalent to </p><div class="fragment"><div class="line">std::make_pair(c.lower_bound(val),</div>
<div class="line">               c.upper_bound(val))</div>
</div><!-- fragment --><p> (but is faster than making the calls separately).</p>
<p>This function probably only makes sense for multimaps. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01435">1435</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a5e0d4434a099805754b757634f18cc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0d4434a099805754b757634f18cc23">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">std::pair</a>&lt;iterator, iterator&gt; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pairs to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function is equivalent to </p><div class="fragment"><div class="line">std::make_pair(c.lower_bound(val),</div>
<div class="line">               c.upper_bound(val))</div>
</div><!-- fragment --><p> (but is faster than making the calls separately).</p>
<p>This function probably only makes sense for multimaps. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01400">1400</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="ad849929336a71e065e43fdf6a294140e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad849929336a71e065e43fdf6a294140e">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">std::pair</a>&lt;const_iterator, const_iterator&gt; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pairs to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of read-only (constant) iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function is equivalent to </p><div class="fragment"><div class="line">std::make_pair(c.lower_bound(val),</div>
<div class="line">               c.upper_bound(val))</div>
</div><!-- fragment --><p> (but is faster than making the calls separately).</p>
<p>This function probably only makes sense for multimaps. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01429">1429</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a6b510fc380b070d899d73a278cbb8faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b510fc380b070d899d73a278cbb8faf">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases elements according to the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements erased.</dd></dl>
<p>This function erases all the elements located by the given key from a map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01116">1116</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="aa98a4bd34df51b51262b26f06a657efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98a4bd34df51b51262b26f06a657efe">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases a [first,last) range of elements from a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the start of the range to be erased. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to the end of the range to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator <em>__last</em>.</dd></dl>
<p>This function erases a sequence of elements from a map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01136">1136</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="ac9ea51e48199ff9a87ea1b855789e53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ea51e48199ff9a87ea1b855789e53d">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an element from a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator pointing to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element immediately following <em>position</em> prior to the element being erased. If no such element exists, end() is returned.</dd></dl>
<p>This function erases an element, pointed to by the given iterator, from a map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01079">1079</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="ae60f51e27db51a169ee4e368d238f69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60f51e27db51a169ee4e368d238f69e">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_GLIBCXX_ABI_TAG_CXX11 iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>__position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an element from a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator pointing to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element immediately following <em>position</em> prior to the element being erased. If no such element exists, end() is returned.</dd></dl>
<p>This function erases an element, pointed to by the given iterator, from a map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01085">1085</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a999812d7c30caadb58cf5beecea28fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999812d7c30caadb58cf5beecea28fa9">&#9670;&nbsp;</a></span>extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_type <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a node. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00654">654</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a8d0e0fd8f88724733e12cdd9f78b00d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0e0fd8f88724733e12cdd9f78b00d7">&#9670;&nbsp;</a></span>extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_type <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a node. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00646">646</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a39303b5617b240f3049dbb0d195789f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39303b5617b240f3049dbb0d195789f5">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> -&gt; decltype(_M_t._M_find_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after pair. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01223">1223</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="accf5f3477b6615f6b31fcb1adf068dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf5f3477b6615f6b31fcb1adf068dfc">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; decltype(_M_t._M_find_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns a constant iterator pointing to the sought after pair. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01248">1248</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="abdcd985632d8ad7ddba069aa776e2dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcd985632d8ad7ddba069aa776e2dfe">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after pair. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01217">1217</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a07cdb0ebaf753ec1244849dbff2ec4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cdb0ebaf753ec1244849dbff2ec4cf">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns a constant iterator pointing to the sought after pair. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01242">1242</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="adc72d6a2972834a9f512d424310468a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc72d6a2972834a9f512d424310468a7">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the memory allocation object. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00356">356</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a3186e7576e4ffc474fd92f66e460d231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3186e7576e4ffc474fd92f66e460d231">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template function that attempts to insert a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the start of the range to be inserted. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to the end of the range.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity similar to that of the range constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00941">941</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="ad95452a6c3677b7176b6b8e3d24e9176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95452a6c3677b7176b6b8e3d24e9176">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Pair &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__enable_if_t&lt;<a class="el" href="a04018.html">is_constructible</a>&lt;<a class="el" href="a08610.html">value_type</a>, _Pair&gt;::value, <a class="el" href="a08610.html">pair</a>&lt;iterator, bool&gt; &gt; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">_Pair &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</dd></dl>
<p>This function attempts to insert a (key, value) pair into the map. A map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the map.</p>
<p>Insertion requires logarithmic time. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00846">846</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00683_source.html#l00636">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::emplace_hint()</a>, <a class="el" href="a00683_source.html#l00384">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::end()</a>, <a class="el" href="a00683_source.html#l01190">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::key_comp()</a>, and <a class="el" href="a00683_source.html#l01306">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::lower_bound()</a>.</p>

</div>
</div>
<a id="a3a5341d2ce3f2ffa4426d29110ca8e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5341d2ce3f2ffa4426d29110ca8e41">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">std::pair</a>&lt;iterator, bool&gt; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08610.html">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</dd></dl>
<p>This function attempts to insert a (key, value) pair into the map. A map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the map.</p>
<p>Insertion requires logarithmic time. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00833">833</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a754f1efe2731112bcb8208d177623445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754f1efe2731112bcb8208d177623445">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__nh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-insert an extracted node. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00664">664</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="a9296f57a3c7c517446504a256dcc48de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9296f57a3c7c517446504a256dcc48de">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Pair &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__enable_if_t&lt;<a class="el" href="a04018.html">is_constructible</a>&lt;<a class="el" href="a08610.html">value_type</a>, _Pair&gt;::value, iterator&gt; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Pair &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires logarithmic time (if the hint is not taken). </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00923">923</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="aa0d825fbc11a62dc06420646e0c90dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d825fbc11a62dc06420646e0c90dd5">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08610.html">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires logarithmic time (if the hint is not taken). </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00908">908</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a99ddc0c2cfe1d8a8cac10a2b59207c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ddc0c2cfe1d8a8cac10a2b59207c68">&#9670;&nbsp;</a></span>insert() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08610.html">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires logarithmic time (if the hint is not taken). </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00918">918</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="a35ab2a881fab728dacf8db3253497851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ab2a881fab728dacf8db3253497851">&#9670;&nbsp;</a></span>insert() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">insert_return_type <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">node_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__nh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-insert an extracted node. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00659">659</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00683_source.html#l00878">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a id="ab228710aaa8c81fc3b7fe37b26fc709a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab228710aaa8c81fc3b7fe37b26fc709a">&#9670;&nbsp;</a></span>insert() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">std::initializer_list</a>&lt; <a class="el" href="a08610.html">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a list of std::pairs into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__list</td><td>A std::initializer_list&lt;value_type&gt; of pairs to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity similar to that of the range constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00878">878</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00683_source.html#l00659">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a id="a94b8084648ff490a86c7cf951f537a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b8084648ff490a86c7cf951f537a37">&#9670;&nbsp;</a></span>insert() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">std::pair</a>&lt;iterator, bool&gt; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08610.html">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</dd></dl>
<p>This function attempts to insert a (key, value) pair into the map. A map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the map.</p>
<p>Insertion requires logarithmic time. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00840">840</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="a252f2554cf85af68c52a8413ef6bd981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252f2554cf85af68c52a8413ef6bd981">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">pair</a>&lt;iterator, bool&gt; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Obj &amp;&amp;&#160;</td>
          <td class="paramname"><em>__obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert or assign a std::pair into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__k</td><td>Key to use for finding a possibly existing pair in the map. </td></tr>
    <tr><td class="paramname">__obj</td><td>Argument used to generate the .second for a pair instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</dd></dl>
<p>This function attempts to insert a (key, value) pair into the map. A map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the map. If the pair was already in the map, the .second of the pair is assigned from __obj.</p>
<p>Insertion requires logarithmic time. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00966">966</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00683_source.html#l00636">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::emplace_hint()</a>, <a class="el" href="a00683_source.html#l00384">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::end()</a>, <a class="el" href="a00221_source.html#l01589">std::forward_as_tuple()</a>, <a class="el" href="a00683_source.html#l01190">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::key_comp()</a>, <a class="el" href="a00683_source.html#l01306">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::lower_bound()</a>, and <a class="el" href="a00695_source.html#l00083">std::piecewise_construct</a>.</p>

</div>
</div>
<a id="a50b126919b98ad8e8dc76d44bad98280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b126919b98ad8e8dc76d44bad98280">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Obj &amp;&amp;&#160;</td>
          <td class="paramname"><em>__obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert or assign a std::pair into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__hint</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__k</td><td>Key to use for finding a possibly existing pair in the map. </td></tr>
    <tr><td class="paramname">__obj</td><td>Argument used to generate the .second for a pair instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</dd></dl>
<p>This function attempts to insert a (key, value) pair into the map. A map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the map. If the pair was already in the map, the .second of the pair is assigned from __obj.</p>
<p>Insertion requires logarithmic time. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01021">1021</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00683_source.html#l00636">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::emplace_hint()</a>, <a class="el" href="a00221_source.html#l01589">std::forward_as_tuple()</a>, and <a class="el" href="a00695_source.html#l00083">std::piecewise_construct</a>.</p>

</div>
</div>
<a id="a59af09cf176afb26d8e2657581429d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59af09cf176afb26d8e2657581429d3f">&#9670;&nbsp;</a></span>key_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">key_compare <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the key comparison object out of which the map was constructed. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01190">1190</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00683_source.html#l00547">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::at()</a>, <a class="el" href="a00683_source.html#l00846">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert()</a>, <a class="el" href="a00683_source.html#l00966">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert_or_assign()</a>, and <a class="el" href="a00683_source.html#l00721">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::try_emplace()</a>.</p>

</div>
</div>
<a id="a5db81ee7912a625e5d7ead27f0cb4133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db81ee7912a625e5d7ead27f0cb4133">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> -&gt; decltype(iterator(_M_t._M_lower_bound_tr(__x)))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the beginning of a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to first element equal to or greater than key, or end().</dd></dl>
<p>This function returns the first element of a subsequence of elements that matches the given key. If unsuccessful it returns an iterator pointing to the first element that has a greater value than given key or end() if no such element exists. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01312">1312</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a2dfc6f822052135a0b48e0dca314ccaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfc6f822052135a0b48e0dca314ccaf">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the beginning of a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) iterator pointing to first element equal to or greater than key, or end().</dd></dl>
<p>This function returns the first element of a subsequence of elements that matches the given key. If unsuccessful it returns an iterator pointing to the first element that has a greater value than given key or end() if no such element exists. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01337">1337</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="adbb7e90f8d6bece7f9ffb6b76c9ab081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb7e90f8d6bece7f9ffb6b76c9ab081">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the beginning of a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to first element equal to or greater than key, or end().</dd></dl>
<p>This function returns the first element of a subsequence of elements that matches the given key. If unsuccessful it returns an iterator pointing to the first element that has a greater value than given key or end() if no such element exists. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01306">1306</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00683_source.html#l00547">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::at()</a>, <a class="el" href="a00683_source.html#l00846">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert()</a>, <a class="el" href="a00683_source.html#l00966">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert_or_assign()</a>, and <a class="el" href="a00683_source.html#l00721">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::try_emplace()</a>.</p>

</div>
</div>
<a id="ab801bf5b252cc1b28af052263ce33d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab801bf5b252cc1b28af052263ce33d7a">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the beginning of a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) iterator pointing to first element equal to or greater than key, or end().</dd></dl>
<p>This function returns the first element of a subsequence of elements that matches the given key. If unsuccessful it returns an iterator pointing to the first element that has a greater value than given key or end() if no such element exists. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01331">1331</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="af2c022c3b246d7beb4c6eae4d6ce7ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c022c3b246d7beb4c6eae4d6ce7ca2">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum size of the map. <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00485">485</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a0ffbbf85c084d61ab49c7fec028bafba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffbbf85c084d61ab49c7fec028bafba">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">map</a>&amp; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08702.html">map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map assignment operator. </p>
<p>Whether the allocator is copied depends on the allocator traits. </p>

</div>
</div>
<a id="ac01f44f3ed4b9dbebcb046b4103f920c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01f44f3ed4b9dbebcb046b4103f920c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">map</a>&amp; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08610.html">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map list assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a map with copies of the elements in the initializer list <em>__l</em>.</p>
<p>Note that the assignment completely changes the map and that the resulting map's size is the same as the number of elements assigned. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00347">347</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a28b4c4feee2bbdf398540f4097d4bb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b4c4feee2bbdf398540f4097d4bb91">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08702.html">map</a>&amp; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08702.html">map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a id="a4a4a9f95131baf0713596d672ec36b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4a9f95131baf0713596d672ec36b5f">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mapped_type&amp; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript ( <code></code>[] ) access to map data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__k</td><td>The key for which data should be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the data of the (key,data) pair.</dd></dl>
<p>Allows for easy lookup with the subscript ( <code></code>[] ) operator. Returns data associated with the key specified in subscript. If the key does not exist, a pair with that key is created using default values, which is then returned.</p>
<p>Lookup requires logarithmic time. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00502">502</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a461fb30e5fd8953549843ff651d06ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461fb30e5fd8953549843ff651d06ec8">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08518.html">const_reverse_iterator</a> <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to the last pair in the map. Iteration is done in descending order according to the keys. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00411">411</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a4ca3db2d238641b23001310899d884fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca3db2d238641b23001310899d884fb">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08518.html">reverse_iterator</a> <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reverse iterator that points to the last pair in the map. Iteration is done in descending order according to the keys. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00402">402</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a21512c1e39cedc32e0275f89f888d4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21512c1e39cedc32e0275f89f888d4aa">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08518.html">const_reverse_iterator</a> <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to one before the first pair in the map. Iteration is done in descending order according to the keys. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00429">429</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="aa467231586b6bc6388765ec6802aef54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa467231586b6bc6388765ec6802aef54">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08518.html">reverse_iterator</a> <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reverse iterator that points to one before the first pair in the map. Iteration is done in descending order according to the keys. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00420">420</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="ab8dd27409135bbee5bb626cd72e0cddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8dd27409135bbee5bb626cd72e0cddb">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the map. <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00480">480</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a6ab3829e42e61a94d9039fea4c07b62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab3829e42e61a94d9039fea4c07b62f">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08702.html">map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps data with another map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A map of the same element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>This exchanges the elements between two maps in constant time. (It is only swapping a pointer, an integer, and an instance of the <code>Compare</code> type (which itself is often stateless and empty), so it should be quite fast.) Note that the global std::swap() function is specialized such that std::swap(m1,m2) will feed to this function.</p>
<p>Whether the allocators are swapped depends on the allocator traits. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01170">1170</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a841a686dcb65f3031dff39d54dbbc0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841a686dcb65f3031dff39d54dbbc0c2">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">pair</a>&lt;iterator, bool&gt; <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to build and insert a std::pair into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__k</td><td>Key to use for finding a possibly existing pair in the map. </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments used to generate the .second for a new pair instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</dd></dl>
<p>This function attempts to build and insert a (key, value) pair into the map. A map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the map. If a pair is not inserted, this function has no effect.</p>
<p>Insertion requires logarithmic time. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00721">721</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00683_source.html#l00636">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::emplace_hint()</a>, <a class="el" href="a00683_source.html#l00384">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::end()</a>, <a class="el" href="a00221_source.html#l01589">std::forward_as_tuple()</a>, <a class="el" href="a00683_source.html#l01190">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::key_comp()</a>, <a class="el" href="a00683_source.html#l01306">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::lower_bound()</a>, and <a class="el" href="a00695_source.html#l00083">std::piecewise_construct</a>.</p>

</div>
</div>
<a id="a39a87dbbec2f949e278c1fd1834aa8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a87dbbec2f949e278c1fd1834aa8a4">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to build and insert a std::pair into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__hint</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__k</td><td>Key to use for finding a possibly existing pair in the map. </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments used to generate the .second for a new pair instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of the std::pair built from <em>__args</em> (may or may not be that std::pair).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument try_emplace() does. However, if insertion did not take place, this function has no effect. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires logarithmic time (if the hint is not taken). </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l00781">781</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00683_source.html#l00636">std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::emplace_hint()</a>, <a class="el" href="a00221_source.html#l01589">std::forward_as_tuple()</a>, and <a class="el" href="a00695_source.html#l00083">std::piecewise_construct</a>.</p>

</div>
</div>
<a id="a58dfea28ca363de5083ec265382de319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58dfea28ca363de5083ec265382de319">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> -&gt; decltype(iterator(_M_t._M_upper_bound_tr(__x)))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the end of a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element greater than key, or end(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01357">1357</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="abd9ce0ad35c587805de6a54c3e61cd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9ce0ad35c587805de6a54c3e61cd02">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the end of a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) iterator pointing to first iterator greater than key, or end(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01377">1377</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a31f6ba9ed7f80198dd444d6d830a3c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f6ba9ed7f80198dd444d6d830a3c80">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the end of a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element greater than key, or end(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01351">1351</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="afd9ba5f5b31a79317b1c5ec547b9ec6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9ba5f5b31a79317b1c5ec547b9ec6c">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the end of a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of (key, value) pair to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) iterator pointing to first iterator greater than key, or end(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01371">1371</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<a id="a2c51f439c6328b72ebdd7e5e558ef847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c51f439c6328b72ebdd7e5e558ef847">&#9670;&nbsp;</a></span>value_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare  = std::less&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_compare <a class="el" href="a08702.html">std::map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a value comparison object, built from the key comparison object out of which the map was constructed. </p>

<p class="definition">Definition at line <a class="el" href="a00683_source.html#l01198">1198</a> of file <a class="el" href="a00683_source.html">stl_map.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00683_source.html">stl_map.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a01655.html">std</a></li><li class="navelem"><a class="el" href="a08702.html">map</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
