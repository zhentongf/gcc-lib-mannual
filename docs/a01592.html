<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstdc++: Non-Mutating</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a01592.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Non-Mutating<div class="ingroups"><a class="el" href="a01590.html">Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Non-Mutating:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01592.svg" width="250" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9947aefb98647043bc1e6fb7be7b77a7"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:ga9947aefb98647043bc1e6fb7be7b77a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#ga9947aefb98647043bc1e6fb7be7b77a7">std::adjacent_find</a> (_ForwardIterator __first, _ForwardIterator __last)</td></tr>
<tr class="separator:ga9947aefb98647043bc1e6fb7be7b77a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd4b6428a016f4d76cfbf9387d418edc"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:gacd4b6428a016f4d76cfbf9387d418edc"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gacd4b6428a016f4d76cfbf9387d418edc">std::adjacent_find</a> (_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)</td></tr>
<tr class="separator:gacd4b6428a016f4d76cfbf9387d418edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c3134ac82616508a419bd6f175ac5b"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Predicate &gt; </td></tr>
<tr class="memitem:ga17c3134ac82616508a419bd6f175ac5b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#ga17c3134ac82616508a419bd6f175ac5b">std::all_of</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)</td></tr>
<tr class="separator:ga17c3134ac82616508a419bd6f175ac5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b398613867eeb30a7fdc043775db128"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Predicate &gt; </td></tr>
<tr class="memitem:ga9b398613867eeb30a7fdc043775db128"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#ga9b398613867eeb30a7fdc043775db128">std::any_of</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)</td></tr>
<tr class="separator:ga9b398613867eeb30a7fdc043775db128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac8d83292f8c124ec62a2b9d5e6046d6"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Tp &gt; </td></tr>
<tr class="memitem:gaac8d83292f8c124ec62a2b9d5e6046d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a05842.html">iterator_traits</a>&lt; _InputIterator &gt;::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gaac8d83292f8c124ec62a2b9d5e6046d6">std::count</a> (_InputIterator __first, _InputIterator __last, const _Tp &amp;__value)</td></tr>
<tr class="separator:gaac8d83292f8c124ec62a2b9d5e6046d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d17b6b93a0b5d369780ef94e45aef6"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Predicate &gt; </td></tr>
<tr class="memitem:ga36d17b6b93a0b5d369780ef94e45aef6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a05842.html">iterator_traits</a>&lt; _InputIterator &gt;::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#ga36d17b6b93a0b5d369780ef94e45aef6">std::count_if</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)</td></tr>
<tr class="separator:ga36d17b6b93a0b5d369780ef94e45aef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed2fda1991d604d055467746c690cf5"><td class="memTemplParams" colspan="2">template&lt;typename _II1 , typename _II2 &gt; </td></tr>
<tr class="memitem:gaaed2fda1991d604d055467746c690cf5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gaaed2fda1991d604d055467746c690cf5">std::equal</a> (_II1 __first1, _II1 __last1, _II2 __first2)</td></tr>
<tr class="separator:gaaed2fda1991d604d055467746c690cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf3d839822c78d538257a0f749f13dcc"><td class="memTemplParams" colspan="2">template&lt;typename _II1 , typename _II2 &gt; </td></tr>
<tr class="memitem:gaaf3d839822c78d538257a0f749f13dcc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gaaf3d839822c78d538257a0f749f13dcc">std::equal</a> (_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)</td></tr>
<tr class="separator:gaaf3d839822c78d538257a0f749f13dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4286bc1aaad106cc84b98920d9d164c4"><td class="memTemplParams" colspan="2">template&lt;typename _IIter1 , typename _IIter2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga4286bc1aaad106cc84b98920d9d164c4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#ga4286bc1aaad106cc84b98920d9d164c4">std::equal</a> (_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)</td></tr>
<tr class="separator:ga4286bc1aaad106cc84b98920d9d164c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ffc8d7e5f6ce6db54c6ffe9e202e00a"><td class="memTemplParams" colspan="2">template&lt;typename _IIter1 , typename _IIter2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga5ffc8d7e5f6ce6db54c6ffe9e202e00a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#ga5ffc8d7e5f6ce6db54c6ffe9e202e00a">std::equal</a> (_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)</td></tr>
<tr class="separator:ga5ffc8d7e5f6ce6db54c6ffe9e202e00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcb0c1e78b0d3abf6113a1bd3828235b"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Tp &gt; </td></tr>
<tr class="memitem:gabcb0c1e78b0d3abf6113a1bd3828235b"><td class="memTemplItemLeft" align="right" valign="top">constexpr _InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gabcb0c1e78b0d3abf6113a1bd3828235b">std::find</a> (_InputIterator __first, _InputIterator __last, const _Tp &amp;__val)</td></tr>
<tr class="separator:gabcb0c1e78b0d3abf6113a1bd3828235b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15d63dd9d82b9abfc8470ee93c302677"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </td></tr>
<tr class="memitem:ga15d63dd9d82b9abfc8470ee93c302677"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#ga15d63dd9d82b9abfc8470ee93c302677">std::find_end</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)</td></tr>
<tr class="separator:ga15d63dd9d82b9abfc8470ee93c302677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac87ec318bc02e705d66d5fd0fa39ef9b"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:gac87ec318bc02e705d66d5fd0fa39ef9b"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gac87ec318bc02e705d66d5fd0fa39ef9b">std::find_end</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __comp)</td></tr>
<tr class="separator:gac87ec318bc02e705d66d5fd0fa39ef9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8fc4800a95b8265fa9cb95fa59bd0f"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:gaea8fc4800a95b8265fa9cb95fa59bd0f"><td class="memTemplItemLeft" align="right" valign="top">constexpr _InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gaea8fc4800a95b8265fa9cb95fa59bd0f">std::find_first_of</a> (_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2)</td></tr>
<tr class="separator:gaea8fc4800a95b8265fa9cb95fa59bd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf199abbf0999abcad6961a03e1e281a2"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _ForwardIterator , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:gaf199abbf0999abcad6961a03e1e281a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr _InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gaf199abbf0999abcad6961a03e1e281a2">std::find_first_of</a> (_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, _BinaryPredicate __comp)</td></tr>
<tr class="separator:gaf199abbf0999abcad6961a03e1e281a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade6b6b32f46014ba584f31888251ff8f"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Predicate &gt; </td></tr>
<tr class="memitem:gade6b6b32f46014ba584f31888251ff8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr _InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gade6b6b32f46014ba584f31888251ff8f">std::find_if</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)</td></tr>
<tr class="separator:gade6b6b32f46014ba584f31888251ff8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e095b7d34e95787fc4f826f6e588d9"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Predicate &gt; </td></tr>
<tr class="memitem:gaa1e095b7d34e95787fc4f826f6e588d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr _InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gaa1e095b7d34e95787fc4f826f6e588d9">std::find_if_not</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)</td></tr>
<tr class="separator:gaa1e095b7d34e95787fc4f826f6e588d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6cd08fec028e3f3f194d4f7896ee53a"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Function &gt; </td></tr>
<tr class="memitem:gae6cd08fec028e3f3f194d4f7896ee53a"><td class="memTemplItemLeft" align="right" valign="top">constexpr _Function&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gae6cd08fec028e3f3f194d4f7896ee53a">std::for_each</a> (_InputIterator __first, _InputIterator __last, _Function __f)</td></tr>
<tr class="separator:gae6cd08fec028e3f3f194d4f7896ee53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf7d53917685606012e763edd290a6a"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Size , typename _Function &gt; </td></tr>
<tr class="memitem:gadcf7d53917685606012e763edd290a6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr _InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gadcf7d53917685606012e763edd290a6a">std::for_each_n</a> (_InputIterator __first, _Size __n, _Function __f)</td></tr>
<tr class="separator:gadcf7d53917685606012e763edd290a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb5c9b3733f74ddb34f5d6b85539091d"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </td></tr>
<tr class="memitem:gadb5c9b3733f74ddb34f5d6b85539091d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gadb5c9b3733f74ddb34f5d6b85539091d">std::is_permutation</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)</td></tr>
<tr class="separator:gadb5c9b3733f74ddb34f5d6b85539091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f190fd29edcd68d795ede92d3335ca"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:gab0f190fd29edcd68d795ede92d3335ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gab0f190fd29edcd68d795ede92d3335ca">std::is_permutation</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred)</td></tr>
<tr class="separator:gab0f190fd29edcd68d795ede92d3335ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf45561caae23ad398330e25945aba8bd"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </td></tr>
<tr class="memitem:gaf45561caae23ad398330e25945aba8bd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gaf45561caae23ad398330e25945aba8bd">std::is_permutation</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)</td></tr>
<tr class="separator:gaf45561caae23ad398330e25945aba8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad272d7d10f9a23c8ce39ea30d286609c"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:gad272d7d10f9a23c8ce39ea30d286609c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gad272d7d10f9a23c8ce39ea30d286609c">std::is_permutation</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)</td></tr>
<tr class="separator:gad272d7d10f9a23c8ce39ea30d286609c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42c6486a4ecbe99a5c9f0c35476c3dfd"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; </td></tr>
<tr class="memitem:ga42c6486a4ecbe99a5c9f0c35476c3dfd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08610.html">pair</a>&lt; _InputIterator1, _InputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#ga42c6486a4ecbe99a5c9f0c35476c3dfd">std::mismatch</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)</td></tr>
<tr class="separator:ga42c6486a4ecbe99a5c9f0c35476c3dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb3a35d203f3cabb80b29280326d228f"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:gadb3a35d203f3cabb80b29280326d228f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08610.html">pair</a>&lt; _InputIterator1, _InputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gadb3a35d203f3cabb80b29280326d228f">std::mismatch</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)</td></tr>
<tr class="separator:gadb3a35d203f3cabb80b29280326d228f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c98f3d33806548286d03d46d63d46e5"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; </td></tr>
<tr class="memitem:ga9c98f3d33806548286d03d46d63d46e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08610.html">pair</a>&lt; _InputIterator1, _InputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#ga9c98f3d33806548286d03d46d63d46e5">std::mismatch</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)</td></tr>
<tr class="separator:ga9c98f3d33806548286d03d46d63d46e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d57eabf2ccbc15190c47b17b6b0b495"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga9d57eabf2ccbc15190c47b17b6b0b495"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08610.html">pair</a>&lt; _InputIterator1, _InputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#ga9d57eabf2ccbc15190c47b17b6b0b495">std::mismatch</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred)</td></tr>
<tr class="separator:ga9d57eabf2ccbc15190c47b17b6b0b495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac29843ee5bba1e64ad95375984c37010"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Predicate &gt; </td></tr>
<tr class="memitem:gac29843ee5bba1e64ad95375984c37010"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gac29843ee5bba1e64ad95375984c37010">std::none_of</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)</td></tr>
<tr class="separator:gac29843ee5bba1e64ad95375984c37010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14978d1be4cc96df88c228f4ca884349"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </td></tr>
<tr class="memitem:ga14978d1be4cc96df88c228f4ca884349"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#ga14978d1be4cc96df88c228f4ca884349">std::search</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)</td></tr>
<tr class="separator:ga14978d1be4cc96df88c228f4ca884349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ddce7bee4af69da9a53de1eca385b2"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga06ddce7bee4af69da9a53de1eca385b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#ga06ddce7bee4af69da9a53de1eca385b2">std::search</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __predicate)</td></tr>
<tr class="separator:ga06ddce7bee4af69da9a53de1eca385b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3ed6cdaf87857588954bb89f22de04b"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator , typename _Integer , typename _Tp &gt; </td></tr>
<tr class="memitem:gac3ed6cdaf87857588954bb89f22de04b"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gac3ed6cdaf87857588954bb89f22de04b">std::search_n</a> (_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &amp;__val)</td></tr>
<tr class="separator:gac3ed6cdaf87857588954bb89f22de04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4482975f81c459e9493144da27d7d35"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator , typename _Integer , typename _Tp , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:gae4482975f81c459e9493144da27d7d35"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01592.html#gae4482975f81c459e9493144da27d7d35">std::search_n</a> (_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &amp;__val, _BinaryPredicate __binary_pred)</td></tr>
<tr class="separator:gae4482975f81c459e9493144da27d7d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9947aefb98647043bc1e6fb7be7b77a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9947aefb98647043bc1e6fb7be7b77a7">&#9670;&nbsp;</a></span>adjacent_find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator std::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find two adjacent values in a sequence that are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code></code>[__first,__last) and such that <code>*i</code> == <code>*</code>(i+1), or <code>__last</code> if no such iterator exists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03974">3974</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gacd4b6428a016f4d76cfbf9387d418edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd4b6428a016f4d76cfbf9387d418edc">&#9670;&nbsp;</a></span>adjacent_find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator std::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find two adjacent values in a sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code></code>[__first,__last) and such that <code>__binary_pred</code>(<em>i,</em>(i+1)) is true, or <code>__last</code> if no such iterator exists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04000">4000</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga17c3134ac82616508a419bd6f175ac5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17c3134ac82616508a419bd6f175ac5b">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::all_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that a predicate is true for all the elements of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the check is true, false otherwise.</dd></dl>
<p>Returns true if <code>__pred</code> is true for each element in the range <code></code>[__first,__last), and false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l00455">455</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga9b398613867eeb30a7fdc043775db128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b398613867eeb30a7fdc043775db128">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::any_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that a predicate is true for at least one element of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the check is true, false otherwise.</dd></dl>
<p>Returns true if an element exists in the range <code></code>[__first,__last) such that <code>__pred</code> is true, and false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l00492">492</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaac8d83292f8c124ec62a2b9d5e6046d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac8d83292f8c124ec62a2b9d5e6046d6">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a05842.html">iterator_traits</a>&lt;_InputIterator&gt;::difference_type std::count </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of copies of a value in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterators <code>i</code> in the range <code></code>[__first,__last) for which <code>*i</code> == <code>__value</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04026">4026</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga36d17b6b93a0b5d369780ef94e45aef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36d17b6b93a0b5d369780ef94e45aef6">&#9670;&nbsp;</a></span>count_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a05842.html">iterator_traits</a>&lt;_InputIterator&gt;::difference_type std::count_if </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the elements of a sequence for which a predicate is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterators <code>i</code> in the range <code></code>[__first,__last) for which <code>__pred(*i)</code> is true. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04050">4050</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaaed2fda1991d604d055467746c690cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaed2fda1991d604d055467746c690cf5">&#9670;&nbsp;</a></span>equal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _II1 , typename _II2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::equal </td>
          <td>(</td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests a range for element-wise equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>This compares the elements of two ranges using <code>==</code> and returns true or false depending on whether all of the corresponding elements of the ranges are equal. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l01545">1545</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gaaf3d839822c78d538257a0f749f13dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf3d839822c78d538257a0f749f13dcc">&#9670;&nbsp;</a></span>equal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _II1 , typename _II2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::equal </td>
          <td>(</td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests a range for element-wise equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>This compares the elements of two ranges using <code>==</code> and returns true or false depending on whether all of the corresponding elements of the ranges are equal. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l01666">1666</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="ga4286bc1aaad106cc84b98920d9d164c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4286bc1aaad106cc84b98920d9d164c4">&#9670;&nbsp;</a></span>equal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _IIter1 , typename _IIter2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::equal </td>
          <td>(</td>
          <td class="paramtype">_IIter1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_IIter1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_IIter2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests a range for element-wise equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate <a class="el" href="a01607.html">functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>This compares the elements of two ranges using the binary_pred parameter, and returns true or false depending on whether all of the corresponding elements of the ranges are equal. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l01576">1576</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="ga5ffc8d7e5f6ce6db54c6ffe9e202e00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ffc8d7e5f6ce6db54c6ffe9e202e00a">&#9670;&nbsp;</a></span>equal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _IIter1 , typename _IIter2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::equal </td>
          <td>(</td>
          <td class="paramtype">_IIter1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_IIter1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_IIter2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_IIter2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests a range for element-wise equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate <a class="el" href="a01607.html">functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>This compares the elements of two ranges using the binary_pred parameter, and returns true or false depending on whether all of the corresponding elements of the ranges are equal. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l01699">1699</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gabcb0c1e78b0d3abf6113a1bd3828235b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcb0c1e78b0d3abf6113a1bd3828235b">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _InputIterator std::find </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a value in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>*i</code> == <code>__val</code>, or <code>__last</code> if no such iterator exists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03843">3843</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga15d63dd9d82b9abfc8470ee93c302677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15d63dd9d82b9abfc8470ee93c302677">&#9670;&nbsp;</a></span>find_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator1 std::find_end </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find last matching subsequence in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence to match. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>*</code>(i+N) == <code>*</code>(__first2+N) for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) and returns an iterator to the __first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found. The sub-sequence will be the last such subsequence contained in [__first1,__last1).</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2)) </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l00370">370</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gac87ec318bc02e705d66d5fd0fa39ef9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac87ec318bc02e705d66d5fd0fa39ef9b">&#9670;&nbsp;</a></span>find_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator1 std::find_end </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find last matching subsequence in a sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence to match. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence to match. </td></tr>
    <tr><td class="paramname">__comp</td><td>The predicate to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>predicate</code>(*(i+N), <code></code>(__first2+N)) is true for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) using comp as a predicate and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found. The sub-sequence will be the last such subsequence contained in [__first,__last1).</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2)) </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l00420">420</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaea8fc4800a95b8265fa9cb95fa59bd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea8fc4800a95b8265fa9cb95fa59bd0f">&#9670;&nbsp;</a></span>find_first_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _InputIterator std::find_first_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find element from a set in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of match candidates. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of match candidates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1) such that <code>*i</code> == <code>*</code>(i2) such that i2 is an iterator in [__first2,__last2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for an element that is equal to some element in the range [__first2,__last2). If found, returns an iterator in the range [__first1,__last1), otherwise returns <code>__last1</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03900">3900</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaf199abbf0999abcad6961a03e1e281a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf199abbf0999abcad6961a03e1e281a2">&#9670;&nbsp;</a></span>find_first_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _ForwardIterator , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _InputIterator std::find_first_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find element from a set in a sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of match candidates. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of match candidates. </td></tr>
    <tr><td class="paramname">__comp</td><td>Predicate to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1) such that <code>comp</code>(*i, <code>*</code>(i2)) is true and i2 is an iterator in [__first2,__last2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for an element that is equal to some element in the range [__first2,__last2). If found, returns an iterator in the range [__first1,__last1), otherwise returns <code>__last1</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03942">3942</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gade6b6b32f46014ba584f31888251ff8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade6b6b32f46014ba584f31888251ff8f">&#9670;&nbsp;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _InputIterator std::find_if </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first element in a sequence for which a predicate is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>__pred(*i)</code> is true, or <code>__last</code> if no such iterator exists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03868">3868</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00650_source.html#l00473">std::none_of()</a>.</p>

</div>
</div>
<a id="gaa1e095b7d34e95787fc4f826f6e588d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1e095b7d34e95787fc4f826f6e588d9">&#9670;&nbsp;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _InputIterator std::find_if_not </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first element in a sequence for which a predicate is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>__pred(*i)</code> is false, or <code>__last</code> if no such iterator exists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l00508">508</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gae6cd08fec028e3f3f194d4f7896ee53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6cd08fec028e3f3f194d4f7896ee53a">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _Function std::for_each </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Function&#160;</td>
          <td class="paramname"><em>__f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to every element of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__f</td><td>A unary function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>__f</code> </dd></dl>
<p>Applies the function object <code>__f</code> to each element in the range <code></code>[first,last). <code>__f</code> must not modify the order of the sequence. If <code>__f</code> has a return value it is ignored. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03781">3781</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gadcf7d53917685606012e763edd290a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcf7d53917685606012e763edd290a6a">&#9670;&nbsp;</a></span>for_each_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Size , typename _Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _InputIterator std::for_each_n </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Size&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Function&#160;</td>
          <td class="paramname"><em>__f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to every element of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>A value convertible to an integer. </td></tr>
    <tr><td class="paramname">__f</td><td>A unary function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>__first+__n</code></dd></dl>
<p>Applies the function object <code>__f</code> to each element in the range <code>[first, first+n)</code>. <code>__f</code> must not modify the order of the sequence. If <code>__f</code> has a return value it is ignored. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03807">3807</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="gadb5c9b3733f74ddb34f5d6b85539091d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb5c9b3733f74ddb34f5d6b85539091d">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::is_permutation </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a permutation of the second sequence is equal to the first sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there exists a permutation of the elements in the range [__first2, __first2 + (__last1 - __first1)), beginning with ForwardIterator2 begin, such that equal(__first1, __last1, begin) returns true; otherwise, returns false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l02202">2202</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gab0f190fd29edcd68d795ede92d3335ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0f190fd29edcd68d795ede92d3335ca">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::is_permutation </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a permutation of the second sequence is equal to the first sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there exists a permutation of the elements in the range [__first2, __first2 + (__last1 - __first1)), beginning with ForwardIterator2 begin, such that equal(__first1, __last1, __begin, __pred) returns true; otherwise, returns false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03470">3470</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaf45561caae23ad398330e25945aba8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf45561caae23ad398330e25945aba8bd">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::is_permutation </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a permutaion of the second sequence is equal to the first sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of first range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there exists a permutation of the elements in the range [__first2, __last2), beginning with ForwardIterator2 begin, such that equal(__first1, __last1, begin) returns true; otherwise, returns false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03564">3564</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gad272d7d10f9a23c8ce39ea30d286609c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad272d7d10f9a23c8ce39ea30d286609c">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::is_permutation </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a permutation of the second sequence is equal to the first sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there exists a permutation of the elements in the range [__first2, __last2), beginning with ForwardIterator2 begin, such that equal(__first1, __last1, __begin, __pred) returns true; otherwise, returns false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03593">3593</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga42c6486a4ecbe99a5c9f0c35476c3dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42c6486a4ecbe99a5c9f0c35476c3dfd">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08610.html">pair</a>&lt;_InputIterator1, _InputIterator2&gt; std::mismatch </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the places in ranges which don't match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first mismatch.</dd></dl>
<p>This compares the elements of two ranges using <code>==</code> and returns a pair of iterators. The first iterator points into the first range, the second iterator points into the second range, and the elements pointed to by the iterators are not equal. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l01906">1906</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gadb3a35d203f3cabb80b29280326d228f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb3a35d203f3cabb80b29280326d228f">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08610.html">pair</a>&lt;_InputIterator1, _InputIterator2&gt; std::mismatch </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the places in ranges which don't match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate <a class="el" href="a01607.html">functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first mismatch.</dd></dl>
<p>This compares the elements of two ranges using the binary_pred parameter, and returns a pair of iterators. The first iterator points into the first range, the second iterator points into the second range, and the elements pointed to by the iterators are not equal. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l01941">1941</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="ga9c98f3d33806548286d03d46d63d46e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c98f3d33806548286d03d46d63d46e5">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08610.html">pair</a>&lt;_InputIterator1, _InputIterator2&gt; std::mismatch </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the places in ranges which don't match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first mismatch.</dd></dl>
<p>This compares the elements of two ranges using <code>==</code> and returns a pair of iterators. The first iterator points into the first range, the second iterator points into the second range, and the elements pointed to by the iterators are not equal. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l01989">1989</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="ga9d57eabf2ccbc15190c47b17b6b0b495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d57eabf2ccbc15190c47b17b6b0b495">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08610.html">pair</a>&lt;_InputIterator1, _InputIterator2&gt; std::mismatch </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the places in ranges which don't match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate <a class="el" href="a01607.html">functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first mismatch.</dd></dl>
<p>This compares the elements of two ranges using the binary_pred parameter, and returns a pair of iterators. The first iterator points into the first range, the second iterator points into the second range, and the elements pointed to by the iterators are not equal. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l02026">2026</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gac29843ee5bba1e64ad95375984c37010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac29843ee5bba1e64ad95375984c37010">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::none_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that a predicate is false for all the elements of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the check is true, false otherwise.</dd></dl>
<p>Returns true if <code>__pred</code> is false for each element in the range <code></code>[__first,__last), and false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l00473">473</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00650_source.html#l03868">std::find_if()</a>.</p>

</div>
</div>
<a id="ga14978d1be4cc96df88c228f4ca884349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14978d1be4cc96df88c228f4ca884349">&#9670;&nbsp;</a></span>search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator1 std::search </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a sequence for a matching sub-sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>*</code>(i+N) == <code>*</code>(__first2+N) for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found.</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence.</p>
<p>This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2)) </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04091">4091</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga06ddce7bee4af69da9a53de1eca385b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06ddce7bee4af69da9a53de1eca385b2">&#9670;&nbsp;</a></span>search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator1 std::search </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a sequence for a matching sub-sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__predicate</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>__predicate</code>(*(i+N),*(__first2+N)) is true for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2), using <code>__predicate</code> to determine equality, and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if no such iterator exists.</p>
<dl class="section see"><dt>See also</dt><dd>search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2) </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04132">4132</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gac3ed6cdaf87857588954bb89f22de04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3ed6cdaf87857588954bb89f22de04b">&#9670;&nbsp;</a></span>search_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Integer , typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator std::search_n </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Integer&#160;</td>
          <td class="paramname"><em>__count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a sequence for a number of consecutive values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last-__count) such that <code>*</code>(i+N) == <code>__val</code> for each <code>N</code> in the range <code></code>[0,__count), or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first,__last) for <code>count</code> consecutive elements equal to <code>__val</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04167">4167</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gae4482975f81c459e9493144da27d7d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4482975f81c459e9493144da27d7d35">&#9670;&nbsp;</a></span>search_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Integer , typename _Tp , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator std::search_n </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Integer&#160;</td>
          <td class="paramname"><em>__count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a sequence for a number of consecutive values using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last-__count) such that <code>__binary_pred</code>(*(i+N),__val) is true for each <code>N</code> in the range <code></code>[0,__count), or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first,__last) for <code>__count</code> consecutive elements for which the predicate returns true. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04202">4202</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
