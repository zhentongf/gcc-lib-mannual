<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstdc++: std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a08926.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a08923.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae4b9c7be5e80745450fb7d8c36f48735"><td class="memItemLeft" align="right" valign="top"><a id="ae4b9c7be5e80745450fb7d8c36f48735"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>insert_return_type</b> = typename _Hashtable::insert_return_type</td></tr>
<tr class="separator:ae4b9c7be5e80745450fb7d8c36f48735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc67bee46a56ca5f523dd755bccdb2d3"><td class="memItemLeft" align="right" valign="top"><a id="afc67bee46a56ca5f523dd755bccdb2d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>node_type</b> = typename _Hashtable::node_type</td></tr>
<tr class="separator:afc67bee46a56ca5f523dd755bccdb2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac563e7804340b706c3efeca91157585b"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::key_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a></td></tr>
<tr class="separator:ac563e7804340b706c3efeca91157585b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e7d39b4a188c7aa535d0431ae8f14c"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a></td></tr>
<tr class="separator:af7e7d39b4a188c7aa535d0431ae8f14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d830d6d91653672a6f20b748327622b"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a6d830d6d91653672a6f20b748327622b">mapped_type</a></td></tr>
<tr class="separator:a6d830d6d91653672a6f20b748327622b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917dcd56682abf611f68cb72cbfb7d3e"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::hasher&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a></td></tr>
<tr class="separator:a917dcd56682abf611f68cb72cbfb7d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5cec3a4b8e6f4030f5baeacf92edbc"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::key_equal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a></td></tr>
<tr class="separator:aab5cec3a4b8e6f4030f5baeacf92edbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434ca8d37d3262f336f06903abbd170b"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a></td></tr>
<tr class="separator:a434ca8d37d3262f336f06903abbd170b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac0072ca4cb745124af7e8ae199b017c5"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ac0072ca4cb745124af7e8ae199b017c5">pointer</a></td></tr>
<tr class="separator:ac0072ca4cb745124af7e8ae199b017c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fbc4a1f8abfebdee17e4d6303c03a3"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a16fbc4a1f8abfebdee17e4d6303c03a3">const_pointer</a></td></tr>
<tr class="separator:a16fbc4a1f8abfebdee17e4d6303c03a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1eaafb2b3f1f11809491426d373485"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a3e1eaafb2b3f1f11809491426d373485">reference</a></td></tr>
<tr class="separator:a3e1eaafb2b3f1f11809491426d373485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3ed5ea37fb02cd6a5eacf89409f52d"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#aaa3ed5ea37fb02cd6a5eacf89409f52d">const_reference</a></td></tr>
<tr class="separator:aaa3ed5ea37fb02cd6a5eacf89409f52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0526d137ece77ce98d550cd2d6fd1816"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a></td></tr>
<tr class="separator:a0526d137ece77ce98d550cd2d6fd1816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0e1b9ce26687d13dace99250f876e3"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a></td></tr>
<tr class="separator:acb0e1b9ce26687d13dace99250f876e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab940536a56eb520d8e7143ce5c4af3a"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::local_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#aab940536a56eb520d8e7143ce5c4af3a">local_iterator</a></td></tr>
<tr class="separator:aab940536a56eb520d8e7143ce5c4af3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cb2cf999f96def015e87c3cca6691d"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::const_local_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#af0cb2cf999f96def015e87c3cca6691d">const_local_iterator</a></td></tr>
<tr class="separator:af0cb2cf999f96def015e87c3cca6691d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefc3dbfc16b70562f92193d01156479"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a></td></tr>
<tr class="separator:acefc3dbfc16b70562f92193d01156479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede8ad7332db3b16e68cec19c0dd963e"><td class="memItemLeft" align="right" valign="top">typedef _Hashtable::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#aede8ad7332db3b16e68cec19c0dd963e">difference_type</a></td></tr>
<tr class="separator:aede8ad7332db3b16e68cec19c0dd963e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6bc68dfdbfb4fe6917fe43aaec5385c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a6bc68dfdbfb4fe6917fe43aaec5385c6">unordered_map</a> ()=default</td></tr>
<tr class="separator:a6bc68dfdbfb4fe6917fe43aaec5385c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6a2a19f1835ba0026844b07b2e5ddb"><td class="memTemplParams" colspan="2"><a id="acf6a2a19f1835ba0026844b07b2e5ddb"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:acf6a2a19f1835ba0026844b07b2e5ddb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unordered_map</b> (_InputIterator __first, _InputIterator __last, <a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n, const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:acf6a2a19f1835ba0026844b07b2e5ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c43b6d88a87da2575ff6951d078bcf"><td class="memTemplParams" colspan="2"><a id="a88c43b6d88a87da2575ff6951d078bcf"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a88c43b6d88a87da2575ff6951d078bcf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unordered_map</b> (_InputIterator __first, _InputIterator __last, <a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n, const <a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a> &amp;__hf, const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a88c43b6d88a87da2575ff6951d078bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bb8e6f25731bdc01fb6c7b34022579"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a94bb8e6f25731bdc01fb6c7b34022579"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#a94bb8e6f25731bdc01fb6c7b34022579">unordered_map</a> (_InputIterator __first, _InputIterator __last, <a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n=0, const <a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a> &amp;__hf=<a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a>(), const <a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a> &amp;__eql=<a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a>(), const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;__a=<a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a>())</td></tr>
<tr class="separator:a94bb8e6f25731bdc01fb6c7b34022579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f6c6ba48b39f7e17b4760d809ebf26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ac2f6c6ba48b39f7e17b4760d809ebf26">unordered_map</a> (const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:ac2f6c6ba48b39f7e17b4760d809ebf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d4ba7519835644688c2230f067a3e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a46d4ba7519835644688c2230f067a3e8">unordered_map</a> (const <a class="el" href="a08926.html">unordered_map</a> &amp;)=default</td></tr>
<tr class="separator:a46d4ba7519835644688c2230f067a3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bd9c76ddf1b09db63f68e5736cc91e"><td class="memItemLeft" align="right" valign="top"><a id="a97bd9c76ddf1b09db63f68e5736cc91e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>unordered_map</b> (const <a class="el" href="a08926.html">unordered_map</a> &amp;__umap, const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a97bd9c76ddf1b09db63f68e5736cc91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8cc557ddc9b1464447a18374cd59ac"><td class="memItemLeft" align="right" valign="top"><a id="aba8cc557ddc9b1464447a18374cd59ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>unordered_map</b> (<a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &gt; __l, <a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n, const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:aba8cc557ddc9b1464447a18374cd59ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9feeae58bbf71d57bc0a9a2992d9f279"><td class="memItemLeft" align="right" valign="top"><a id="a9feeae58bbf71d57bc0a9a2992d9f279"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>unordered_map</b> (<a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &gt; __l, <a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n, const <a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a> &amp;__hf, const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a9feeae58bbf71d57bc0a9a2992d9f279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae490543303c7ea2365e5a53bc7d131"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#acae490543303c7ea2365e5a53bc7d131">unordered_map</a> (<a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &gt; __l, <a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n=0, const <a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a> &amp;__hf=<a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a>(), const <a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a> &amp;__eql=<a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a>(), const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;__a=<a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a>())</td></tr>
<tr class="separator:acae490543303c7ea2365e5a53bc7d131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158680c8684e5854b33d8c42bdcc8467"><td class="memItemLeft" align="right" valign="top"><a id="a158680c8684e5854b33d8c42bdcc8467"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>unordered_map</b> (<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n, const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a158680c8684e5854b33d8c42bdcc8467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46152dcddb7f940306d76f2b282d4a0"><td class="memItemLeft" align="right" valign="top"><a id="aa46152dcddb7f940306d76f2b282d4a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>unordered_map</b> (<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n, const <a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a> &amp;__hf, const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:aa46152dcddb7f940306d76f2b282d4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743946b3813b8ec54b762a6edbae2934"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a743946b3813b8ec54b762a6edbae2934">unordered_map</a> (<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n, const <a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a> &amp;__hf=<a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a>(), const <a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a> &amp;__eql=<a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a>(), const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;__a=<a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a>())</td></tr>
<tr class="separator:a743946b3813b8ec54b762a6edbae2934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5924b32a6e46f9deb426e02e524f7d23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a5924b32a6e46f9deb426e02e524f7d23">unordered_map</a> (<a class="el" href="a08926.html">unordered_map</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a5924b32a6e46f9deb426e02e524f7d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125aee135b92b35ad52d662f6d36dcd9"><td class="memItemLeft" align="right" valign="top"><a id="a125aee135b92b35ad52d662f6d36dcd9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>unordered_map</b> (<a class="el" href="a08926.html">unordered_map</a> &amp;&amp;__umap, const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;__a) noexcept(noexcept(_Hashtable(<a class="el" href="a01588.html#ga9f81219bfbfaac50d44f79095a639620">std::move</a>(__umap._M_h), __a)))</td></tr>
<tr class="separator:a125aee135b92b35ad52d662f6d36dcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90866b0f04d5366339b63f8e26bde06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ac90866b0f04d5366339b63f8e26bde06">begin</a> () noexcept</td></tr>
<tr class="separator:ac90866b0f04d5366339b63f8e26bde06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0eddd81ee3d218ade072a8becffaff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#aab940536a56eb520d8e7143ce5c4af3a">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ae0eddd81ee3d218ade072a8becffaff6">begin</a> (<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n)</td></tr>
<tr class="separator:ae0eddd81ee3d218ade072a8becffaff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b65560e775bea99b5e61385dbb3f62"><td class="memItemLeft" align="right" valign="top"><a id="a54b65560e775bea99b5e61385dbb3f62"></a>
<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bucket</b> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__key) const</td></tr>
<tr class="separator:a54b65560e775bea99b5e61385dbb3f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a1a3c1d13adf8908c863a707fa40aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ac8a1a3c1d13adf8908c863a707fa40aa">bucket_count</a> () const noexcept</td></tr>
<tr class="separator:ac8a1a3c1d13adf8908c863a707fa40aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4de483a82e55fca3d263ad430aad793"><td class="memItemLeft" align="right" valign="top"><a id="ac4de483a82e55fca3d263ad430aad793"></a>
<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_size</b> (<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n) const</td></tr>
<tr class="separator:ac4de483a82e55fca3d263ad430aad793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9728c777ec0429619531a26201560c18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a9728c777ec0429619531a26201560c18">clear</a> () noexcept</td></tr>
<tr class="separator:a9728c777ec0429619531a26201560c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c22cafc2b6f068358049c8fdb7bda0"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:aa2c22cafc2b6f068358049c8fdb7bda0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08610.html">std::pair</a>&lt; <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#aa2c22cafc2b6f068358049c8fdb7bda0">emplace</a> (_Args &amp;&amp;... __args)</td></tr>
<tr class="separator:aa2c22cafc2b6f068358049c8fdb7bda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36454c8cd5831988060bdf85a4d4d6e"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:af36454c8cd5831988060bdf85a4d4d6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#af36454c8cd5831988060bdf85a4d4d6e">emplace_hint</a> (<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> __pos, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:af36454c8cd5831988060bdf85a4d4d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d72f478fb0cd05cc612e7ac746131ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a4d72f478fb0cd05cc612e7ac746131ac">empty</a> () const noexcept</td></tr>
<tr class="separator:a4d72f478fb0cd05cc612e7ac746131ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42872e15c417c6f944d019315553951e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a42872e15c417c6f944d019315553951e">end</a> () noexcept</td></tr>
<tr class="separator:a42872e15c417c6f944d019315553951e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91675efcde6f50894587cdb2037a4fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#aab940536a56eb520d8e7143ce5c4af3a">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ab91675efcde6f50894587cdb2037a4fc">end</a> (<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n)</td></tr>
<tr class="separator:ab91675efcde6f50894587cdb2037a4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56149c061cd4aca92d631f7ad5a5a737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a56149c061cd4aca92d631f7ad5a5a737">erase</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__x)</td></tr>
<tr class="separator:a56149c061cd4aca92d631f7ad5a5a737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b17775816c782568baefd357cd50e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a1b17775816c782568baefd357cd50e88">erase</a> (<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> __first, <a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> __last)</td></tr>
<tr class="separator:a1b17775816c782568baefd357cd50e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c23f11a0399cc6c5d5b0f798a347b93"><td class="memItemLeft" align="right" valign="top">node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a0c23f11a0399cc6c5d5b0f798a347b93">extract</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__key)</td></tr>
<tr class="separator:a0c23f11a0399cc6c5d5b0f798a347b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270ed38c6d0ca6a5b6469f01499e8241"><td class="memItemLeft" align="right" valign="top">node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a270ed38c6d0ca6a5b6469f01499e8241">extract</a> (<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> __pos)</td></tr>
<tr class="separator:a270ed38c6d0ca6a5b6469f01499e8241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13808c3062786f090b1af63937f15963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a13808c3062786f090b1af63937f15963">get_allocator</a> () const noexcept</td></tr>
<tr class="separator:a13808c3062786f090b1af63937f15963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9588299378201162e3f7da7e7d30fdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ac9588299378201162e3f7da7e7d30fdf">hash_function</a> () const</td></tr>
<tr class="separator:ac9588299378201162e3f7da7e7d30fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c40f8641ff4ca47fe2998a46404cf37"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a0c40f8641ff4ca47fe2998a46404cf37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#a0c40f8641ff4ca47fe2998a46404cf37">insert</a> (_InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:a0c40f8641ff4ca47fe2998a46404cf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d109f98534443c0d735545930ea0467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a3d109f98534443c0d735545930ea0467">insert</a> (<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>, node_type &amp;&amp;__nh)</td></tr>
<tr class="separator:a3d109f98534443c0d735545930ea0467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191d1d95c2d102dc1057677df000aaec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a191d1d95c2d102dc1057677df000aaec">insert</a> (<a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &gt; __l)</td></tr>
<tr class="separator:a191d1d95c2d102dc1057677df000aaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7886e783fd5c735bbe1bc8f685fea4b"><td class="memItemLeft" align="right" valign="top">insert_return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#af7886e783fd5c735bbe1bc8f685fea4b">insert</a> (node_type &amp;&amp;__nh)</td></tr>
<tr class="separator:af7886e783fd5c735bbe1bc8f685fea4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c7292e78373e719791242496f23a20"><td class="memTemplParams" colspan="2">template&lt;typename _Obj &gt; </td></tr>
<tr class="memitem:a18c7292e78373e719791242496f23a20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08610.html">pair</a>&lt; <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#a18c7292e78373e719791242496f23a20">insert_or_assign</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__k, _Obj &amp;&amp;__obj)</td></tr>
<tr class="separator:a18c7292e78373e719791242496f23a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06399d585c8e22feecd02ddc7f16cd5"><td class="memTemplParams" colspan="2">template&lt;typename _Obj &gt; </td></tr>
<tr class="memitem:ac06399d585c8e22feecd02ddc7f16cd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#ac06399d585c8e22feecd02ddc7f16cd5">insert_or_assign</a> (<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> __hint, const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__k, _Obj &amp;&amp;__obj)</td></tr>
<tr class="separator:ac06399d585c8e22feecd02ddc7f16cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5783438371648b00ef64753597d766a2"><td class="memTemplParams" colspan="2"><a id="a5783438371648b00ef64753597d766a2"></a>
template&lt;typename _Obj &gt; </td></tr>
<tr class="memitem:a5783438371648b00ef64753597d766a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> __hint, <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&amp;__k, _Obj &amp;&amp;__obj)</td></tr>
<tr class="separator:a5783438371648b00ef64753597d766a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2b5dccda5a459a299bd2a74ad9d19a"><td class="memTemplParams" colspan="2"><a id="a3c2b5dccda5a459a299bd2a74ad9d19a"></a>
template&lt;typename _Obj &gt; </td></tr>
<tr class="memitem:a3c2b5dccda5a459a299bd2a74ad9d19a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08610.html">pair</a>&lt; <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign</b> (<a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&amp;__k, _Obj &amp;&amp;__obj)</td></tr>
<tr class="separator:a3c2b5dccda5a459a299bd2a74ad9d19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa956e7eb800e72fbab9b54f3ef006d8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#aa956e7eb800e72fbab9b54f3ef006d8e">key_eq</a> () const</td></tr>
<tr class="separator:aa956e7eb800e72fbab9b54f3ef006d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add961e22f4549e2c94846946fbd25a7d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#add961e22f4549e2c94846946fbd25a7d">load_factor</a> () const noexcept</td></tr>
<tr class="separator:add961e22f4549e2c94846946fbd25a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29f5a18a09a36adb720b6907e45eacd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#af29f5a18a09a36adb720b6907e45eacd">max_bucket_count</a> () const noexcept</td></tr>
<tr class="separator:af29f5a18a09a36adb720b6907e45eacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f58d908f2e03656fce158550d9ba73"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ae2f58d908f2e03656fce158550d9ba73">max_load_factor</a> () const noexcept</td></tr>
<tr class="separator:ae2f58d908f2e03656fce158550d9ba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0584274b6378b6d962debbe96f5c5cb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a0584274b6378b6d962debbe96f5c5cb6">max_load_factor</a> (float __z)</td></tr>
<tr class="separator:a0584274b6378b6d962debbe96f5c5cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695e48bcb2fa9e91ad07d3f7c45016dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a695e48bcb2fa9e91ad07d3f7c45016dd">max_size</a> () const noexcept</td></tr>
<tr class="separator:a695e48bcb2fa9e91ad07d3f7c45016dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bfb768f766e17edd041d25ea6fed29"><td class="memTemplParams" colspan="2"><a id="a21bfb768f766e17edd041d25ea6fed29"></a>
template&lt;typename _H2 , typename _P2 &gt; </td></tr>
<tr class="memitem:a21bfb768f766e17edd041d25ea6fed29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>merge</b> (<a class="el" href="a08926.html">unordered_map</a>&lt; _Key, _Tp, _H2, _P2, _Alloc &gt; &amp;&amp;__source)</td></tr>
<tr class="separator:a21bfb768f766e17edd041d25ea6fed29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09d8babb6b34048e1cc0bd6dff1d890"><td class="memTemplParams" colspan="2"><a id="ab09d8babb6b34048e1cc0bd6dff1d890"></a>
template&lt;typename _H2 , typename _P2 &gt; </td></tr>
<tr class="memitem:ab09d8babb6b34048e1cc0bd6dff1d890"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>merge</b> (<a class="el" href="a08926.html">unordered_map</a>&lt; _Key, _Tp, _H2, _P2, _Alloc &gt; &amp;__source)</td></tr>
<tr class="separator:ab09d8babb6b34048e1cc0bd6dff1d890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3465fcd96a9a575062667d42f2dbc91b"><td class="memTemplParams" colspan="2"><a id="a3465fcd96a9a575062667d42f2dbc91b"></a>
template&lt;typename _H2 , typename _P2 &gt; </td></tr>
<tr class="memitem:a3465fcd96a9a575062667d42f2dbc91b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>merge</b> (<a class="el" href="a08922.html">unordered_multimap</a>&lt; _Key, _Tp, _H2, _P2, _Alloc &gt; &amp;&amp;__source)</td></tr>
<tr class="separator:a3465fcd96a9a575062667d42f2dbc91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72decf4aa2eee1781d1ae732b98bbd31"><td class="memTemplParams" colspan="2"><a id="a72decf4aa2eee1781d1ae732b98bbd31"></a>
template&lt;typename _H2 , typename _P2 &gt; </td></tr>
<tr class="memitem:a72decf4aa2eee1781d1ae732b98bbd31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>merge</b> (<a class="el" href="a08922.html">unordered_multimap</a>&lt; _Key, _Tp, _H2, _P2, _Alloc &gt; &amp;__source)</td></tr>
<tr class="separator:a72decf4aa2eee1781d1ae732b98bbd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0525353d274a1abca19e123ca58702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html">unordered_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#aca0525353d274a1abca19e123ca58702">operator=</a> (const <a class="el" href="a08926.html">unordered_map</a> &amp;)=default</td></tr>
<tr class="separator:aca0525353d274a1abca19e123ca58702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46087d4d85698c13e7fe5e10f13821d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html">unordered_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a46087d4d85698c13e7fe5e10f13821d1">operator=</a> (<a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &gt; __l)</td></tr>
<tr class="separator:a46087d4d85698c13e7fe5e10f13821d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d63494d15ed6c47df072d06d9608ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html">unordered_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a7d63494d15ed6c47df072d06d9608ca0">operator=</a> (<a class="el" href="a08926.html">unordered_map</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a7d63494d15ed6c47df072d06d9608ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81fbed78a715d3c81e8c7655669c7e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#af81fbed78a715d3c81e8c7655669c7e7">rehash</a> (<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n)</td></tr>
<tr class="separator:af81fbed78a715d3c81e8c7655669c7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eee23bd13796426f3018c8a9341202f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a2eee23bd13796426f3018c8a9341202f">reserve</a> (<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n)</td></tr>
<tr class="separator:a2eee23bd13796426f3018c8a9341202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1de2c7389176716aceeaba3b1c2bb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a7d1de2c7389176716aceeaba3b1c2bb7">size</a> () const noexcept</td></tr>
<tr class="separator:a7d1de2c7389176716aceeaba3b1c2bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06bac0d1fbee8603ec2ac806950b1ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ae06bac0d1fbee8603ec2ac806950b1ba">swap</a> (<a class="el" href="a08926.html">unordered_map</a> &amp;__x) noexcept(noexcept(_M_h.swap(__x._M_h)))</td></tr>
<tr class="separator:ae06bac0d1fbee8603ec2ac806950b1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bd22b39287d90f662a2fdc3517ab1d"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a45bd22b39287d90f662a2fdc3517ab1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08610.html">pair</a>&lt; <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#a45bd22b39287d90f662a2fdc3517ab1d">try_emplace</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__k, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a45bd22b39287d90f662a2fdc3517ab1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220092f3c52236249e8e904ff0906b41"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a220092f3c52236249e8e904ff0906b41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#a220092f3c52236249e8e904ff0906b41">try_emplace</a> (<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> __hint, const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__k, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a220092f3c52236249e8e904ff0906b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62671722e3313ba9edda2acebec5bde8"><td class="memTemplParams" colspan="2"><a id="a62671722e3313ba9edda2acebec5bde8"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a62671722e3313ba9edda2acebec5bde8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace</b> (<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> __hint, <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&amp;__k, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:a62671722e3313ba9edda2acebec5bde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bb7bc93a33c8f6858373ad9cfc3367"><td class="memTemplParams" colspan="2"><a id="af6bb7bc93a33c8f6858373ad9cfc3367"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:af6bb7bc93a33c8f6858373ad9cfc3367"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08610.html">pair</a>&lt; <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace</b> (<a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&amp;__k, _Args &amp;&amp;... __args)</td></tr>
<tr class="separator:af6bb7bc93a33c8f6858373ad9cfc3367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9d409d14c46998843b60af82785dfd80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a9d409d14c46998843b60af82785dfd80">begin</a> () const noexcept</td></tr>
<tr class="separator:a9d409d14c46998843b60af82785dfd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9610ba94f6f17e7af50d7280638fa17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#af9610ba94f6f17e7af50d7280638fa17">cbegin</a> () const noexcept</td></tr>
<tr class="separator:af9610ba94f6f17e7af50d7280638fa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6b763e0c9c40786e19c26f5fa97e3ab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a6b763e0c9c40786e19c26f5fa97e3ab6">end</a> () const noexcept</td></tr>
<tr class="separator:a6b763e0c9c40786e19c26f5fa97e3ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab862dadbaf3147cfc02bd383ed35e1f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ab862dadbaf3147cfc02bd383ed35e1f9">cend</a> () const noexcept</td></tr>
<tr class="separator:ab862dadbaf3147cfc02bd383ed35e1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a047d2b3433747276ee6daa9eba154295"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08610.html">std::pair</a>&lt; <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a047d2b3433747276ee6daa9eba154295">insert</a> (const <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &amp;__x)</td></tr>
<tr class="separator:a047d2b3433747276ee6daa9eba154295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb80cc201b9b5b821e8ef73492106db3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08610.html">std::pair</a>&lt; <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#adb80cc201b9b5b821e8ef73492106db3">insert</a> (<a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &amp;&amp;__x)</td></tr>
<tr class="separator:adb80cc201b9b5b821e8ef73492106db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae182defe617c8d37e27b27b09277ea9"><td class="memTemplParams" colspan="2">template&lt;typename _Pair &gt; </td></tr>
<tr class="memitem:aae182defe617c8d37e27b27b09277ea9"><td class="memTemplItemLeft" align="right" valign="top">__enable_if_t&lt; <a class="el" href="a04018.html">is_constructible</a>&lt; <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a>, _Pair &amp;&amp; &gt;::value, <a class="el" href="a08610.html">pair</a>&lt; <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#aae182defe617c8d37e27b27b09277ea9">insert</a> (_Pair &amp;&amp;__x)</td></tr>
<tr class="separator:aae182defe617c8d37e27b27b09277ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3eb7753105411145e2d8476cf300b348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a3eb7753105411145e2d8476cf300b348">insert</a> (<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> __hint, const <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &amp;__x)</td></tr>
<tr class="separator:a3eb7753105411145e2d8476cf300b348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d23be5cd83c13117d269bc1df1488f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a01d23be5cd83c13117d269bc1df1488f">insert</a> (<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> __hint, <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &amp;&amp;__x)</td></tr>
<tr class="separator:a01d23be5cd83c13117d269bc1df1488f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f015606d8e138c72eb87ce5f89ed50"><td class="memTemplParams" colspan="2">template&lt;typename _Pair &gt; </td></tr>
<tr class="memitem:ae4f015606d8e138c72eb87ce5f89ed50"><td class="memTemplItemLeft" align="right" valign="top">__enable_if_t&lt; <a class="el" href="a04018.html">is_constructible</a>&lt; <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a>, _Pair &amp;&amp; &gt;::value, <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#ae4f015606d8e138c72eb87ce5f89ed50">insert</a> (<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> __hint, _Pair &amp;&amp;__x)</td></tr>
<tr class="separator:ae4f015606d8e138c72eb87ce5f89ed50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adef61b0f6b1e43cfdb648e247277ba00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#adef61b0f6b1e43cfdb648e247277ba00">erase</a> (<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> __position)</td></tr>
<tr class="separator:adef61b0f6b1e43cfdb648e247277ba00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04b983f5337e79f121f2df4bbaa283c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ab04b983f5337e79f121f2df4bbaa283c">erase</a> (<a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> __position)</td></tr>
<tr class="separator:ab04b983f5337e79f121f2df4bbaa283c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad62fc2387c4fa4aefe228c14239f8c40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#ad62fc2387c4fa4aefe228c14239f8c40">find</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__x)</td></tr>
<tr class="separator:ad62fc2387c4fa4aefe228c14239f8c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161034f625211298037c2f470616a60e"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:a161034f625211298037c2f470616a60e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#a161034f625211298037c2f470616a60e">find</a> (const _Kt &amp;__x) -&gt; decltype(_M_h._M_find_tr(__x))</td></tr>
<tr class="separator:a161034f625211298037c2f470616a60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589217c1b2ed3f77f57aeb41d5192d0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a589217c1b2ed3f77f57aeb41d5192d0d">find</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__x) const</td></tr>
<tr class="separator:a589217c1b2ed3f77f57aeb41d5192d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17871ecb708fe7527e0d02eb8a157fe5"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:a17871ecb708fe7527e0d02eb8a157fe5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#a17871ecb708fe7527e0d02eb8a157fe5">find</a> (const _Kt &amp;__x) const -&gt; decltype(_M_h._M_find_tr(__x))</td></tr>
<tr class="separator:a17871ecb708fe7527e0d02eb8a157fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4cbd19e5e859635c70822a7e1faa8e36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a4cbd19e5e859635c70822a7e1faa8e36">count</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__x) const</td></tr>
<tr class="separator:a4cbd19e5e859635c70822a7e1faa8e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee86c62d9eeb17f046b8cae47ba8d12"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:aeee86c62d9eeb17f046b8cae47ba8d12"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#aeee86c62d9eeb17f046b8cae47ba8d12">count</a> (const _Kt &amp;__x) const -&gt; decltype(_M_h._M_count_tr(__x))</td></tr>
<tr class="separator:aeee86c62d9eeb17f046b8cae47ba8d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0a209f2b7b3109e8e5b6f96d64bec5ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a0a209f2b7b3109e8e5b6f96d64bec5ab">contains</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__x) const</td></tr>
<tr class="separator:a0a209f2b7b3109e8e5b6f96d64bec5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66441bfe69a60ee7240a0dc2ceec7cc9"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:a66441bfe69a60ee7240a0dc2ceec7cc9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#a66441bfe69a60ee7240a0dc2ceec7cc9">contains</a> (const _Kt &amp;__x) const -&gt; decltype(_M_h._M_find_tr(__x), void(), true)</td></tr>
<tr class="separator:a66441bfe69a60ee7240a0dc2ceec7cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a301e117827c134ed289b5d19e5c8a36e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08610.html">std::pair</a>&lt; <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a301e117827c134ed289b5d19e5c8a36e">equal_range</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__x)</td></tr>
<tr class="separator:a301e117827c134ed289b5d19e5c8a36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c2c2c6bd08cf9a9b997e9ece957c2a"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:a65c2c2c6bd08cf9a9b997e9ece957c2a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#a65c2c2c6bd08cf9a9b997e9ece957c2a">equal_range</a> (const _Kt &amp;__x) -&gt; decltype(_M_h._M_equal_range_tr(__x))</td></tr>
<tr class="separator:a65c2c2c6bd08cf9a9b997e9ece957c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e644ce722b02f5304757ea9be5b23e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08610.html">std::pair</a>&lt; <a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>, <a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a21e644ce722b02f5304757ea9be5b23e">equal_range</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__x) const</td></tr>
<tr class="separator:a21e644ce722b02f5304757ea9be5b23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1f21a557b8cfe1e0a13a6fc2a4e34c"><td class="memTemplParams" colspan="2">template&lt;typename _Kt &gt; </td></tr>
<tr class="memitem:aca1f21a557b8cfe1e0a13a6fc2a4e34c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08926.html#aca1f21a557b8cfe1e0a13a6fc2a4e34c">equal_range</a> (const _Kt &amp;__x) const -&gt; decltype(_M_h._M_equal_range_tr(__x))</td></tr>
<tr class="separator:aca1f21a557b8cfe1e0a13a6fc2a4e34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2d7a21a98b09239b8745900308e63643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a6d830d6d91653672a6f20b748327622b">mapped_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a2d7a21a98b09239b8745900308e63643">operator[]</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__k)</td></tr>
<tr class="separator:a2d7a21a98b09239b8745900308e63643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d659d8a7b18d41726d04ed6451d1ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a6d830d6d91653672a6f20b748327622b">mapped_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a21d659d8a7b18d41726d04ed6451d1ce">operator[]</a> (<a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&amp;__k)</td></tr>
<tr class="separator:a21d659d8a7b18d41726d04ed6451d1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a801392267ec716837238015f8cefe60a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#a6d830d6d91653672a6f20b748327622b">mapped_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a801392267ec716837238015f8cefe60a">at</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__k)</td></tr>
<tr class="separator:a801392267ec716837238015f8cefe60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f78ebfeb9bf55bc807a075eb22cb2aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a08926.html#a6d830d6d91653672a6f20b748327622b">mapped_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a1f78ebfeb9bf55bc807a075eb22cb2aa">at</a> (const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;__k) const</td></tr>
<tr class="separator:a1f78ebfeb9bf55bc807a075eb22cb2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a73cb0bbad75ff10a8493cdb155b81146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#af0cb2cf999f96def015e87c3cca6691d">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a73cb0bbad75ff10a8493cdb155b81146">begin</a> (<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n) const</td></tr>
<tr class="separator:a73cb0bbad75ff10a8493cdb155b81146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326f910adabc220031b93dc6b472b913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#af0cb2cf999f96def015e87c3cca6691d">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a326f910adabc220031b93dc6b472b913">cbegin</a> (<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n) const</td></tr>
<tr class="separator:a326f910adabc220031b93dc6b472b913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a606977180c30d7a49a36846a45f4e355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#af0cb2cf999f96def015e87c3cca6691d">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a606977180c30d7a49a36846a45f4e355">end</a> (<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n) const</td></tr>
<tr class="separator:a606977180c30d7a49a36846a45f4e355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786093f27f238f88c21ecbfe11e27981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08926.html#af0cb2cf999f96def015e87c3cca6691d">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08926.html#a786093f27f238f88c21ecbfe11e27981">cend</a> (<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> __n) const</td></tr>
<tr class="separator:a786093f27f238f88c21ecbfe11e27981"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a972c9b3a213a23489be37d95a4562d87"><td class="memTemplParams" colspan="2"><a id="a972c9b3a213a23489be37d95a4562d87"></a>
template&lt;typename _Key1 , typename _Tp1 , typename _Hash1 , typename _Pred1 , typename _Alloc1 &gt; </td></tr>
<tr class="memitem:a972c9b3a213a23489be37d95a4562d87"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a08926.html">unordered_map</a>&lt; _Key1, _Tp1, _Hash1, _Pred1, _Alloc1 &gt; &amp;, const <a class="el" href="a08926.html">unordered_map</a>&lt; _Key1, _Tp1, _Hash1, _Pred1, _Alloc1 &gt; &amp;)</td></tr>
<tr class="separator:a972c9b3a213a23489be37d95a4562d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ba6094bfef194c2c3895c5ea1efa6d"><td class="memTemplParams" colspan="2"><a id="af0ba6094bfef194c2c3895c5ea1efa6d"></a>
template&lt;typename , typename , typename &gt; </td></tr>
<tr class="memitem:af0ba6094bfef194c2c3895c5ea1efa6d"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::_Hash_merge_helper</b></td></tr>
<tr class="separator:af0ba6094bfef194c2c3895c5ea1efa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Key, typename _Tp, typename _Hash = hash&lt;_Key&gt;, typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;<br />
class std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;</h3>

<p>A standard container composed of unique keys (containing at most one of each key value) that associates values of another type with the keys. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Key</td><td>Type of key objects. </td></tr>
    <tr><td class="paramname">_Tp</td><td>Type of mapped objects. </td></tr>
    <tr><td class="paramname">_Hash</td><td>Hashing function object type, defaults to hash&lt;_Value&gt;. </td></tr>
    <tr><td class="paramname">_Pred</td><td>Predicate function object type, defaults to equal_to&lt;_Value&gt;. </td></tr>
    <tr><td class="paramname">_Alloc</td><td>Allocator type, defaults to std::allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;.</td></tr>
  </table>
  </dd>
</dl>
<p>Meets the requirements of a <a href="tables.html#65">container</a>, and <a href="tables.html#xx">unordered associative container</a></p>
<p>The resulting value type of the container is std::pair&lt;const _Key, _Tp&gt;.</p>
<p>Base is _Hashtable, dispatched at compile time via template alias __umap_hashtable. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00102">102</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a434ca8d37d3262f336f06903abbd170b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434ca8d37d3262f336f06903abbd170b">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::allocator_type <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00116">116</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="acb0e1b9ce26687d13dace99250f876e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0e1b9ce26687d13dace99250f876e3">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::const_iterator <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00126">126</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="af0cb2cf999f96def015e87c3cca6691d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cb2cf999f96def015e87c3cca6691d">&#9670;&nbsp;</a></span>const_local_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::const_local_iterator <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#af0cb2cf999f96def015e87c3cca6691d">const_local_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00128">128</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a16fbc4a1f8abfebdee17e4d6303c03a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fbc4a1f8abfebdee17e4d6303c03a3">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::const_pointer <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#a16fbc4a1f8abfebdee17e4d6303c03a3">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00122">122</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aaa3ed5ea37fb02cd6a5eacf89409f52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3ed5ea37fb02cd6a5eacf89409f52d">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::const_reference <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#aaa3ed5ea37fb02cd6a5eacf89409f52d">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00124">124</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aede8ad7332db3b16e68cec19c0dd963e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede8ad7332db3b16e68cec19c0dd963e">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::difference_type <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#aede8ad7332db3b16e68cec19c0dd963e">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00130">130</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a917dcd56682abf611f68cb72cbfb7d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917dcd56682abf611f68cb72cbfb7d3e">&#9670;&nbsp;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::hasher <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00114">114</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a0526d137ece77ce98d550cd2d6fd1816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0526d137ece77ce98d550cd2d6fd1816">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::iterator <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00125">125</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aab5cec3a4b8e6f4030f5baeacf92edbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5cec3a4b8e6f4030f5baeacf92edbc">&#9670;&nbsp;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::key_equal <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00115">115</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ac563e7804340b706c3efeca91157585b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac563e7804340b706c3efeca91157585b">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::key_type <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00111">111</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aab940536a56eb520d8e7143ce5c4af3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab940536a56eb520d8e7143ce5c4af3a">&#9670;&nbsp;</a></span>local_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::local_iterator <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#aab940536a56eb520d8e7143ce5c4af3a">local_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00127">127</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a6d830d6d91653672a6f20b748327622b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d830d6d91653672a6f20b748327622b">&#9670;&nbsp;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::mapped_type <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#a6d830d6d91653672a6f20b748327622b">mapped_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00113">113</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ac0072ca4cb745124af7e8ae199b017c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0072ca4cb745124af7e8ae199b017c5">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::pointer <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#ac0072ca4cb745124af7e8ae199b017c5">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00121">121</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a3e1eaafb2b3f1f11809491426d373485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1eaafb2b3f1f11809491426d373485">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::reference <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#a3e1eaafb2b3f1f11809491426d373485">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00123">123</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="acefc3dbfc16b70562f92193d01156479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefc3dbfc16b70562f92193d01156479">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::size_type <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00129">129</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="af7e7d39b4a188c7aa535d0431ae8f14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e7d39b4a188c7aa535d0431ae8f14c">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Hashtable::value_type <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00112">112</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6bc68dfdbfb4fe6917fe43aaec5385c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc68dfdbfb4fe6917fe43aaec5385c6">&#9670;&nbsp;</a></span>unordered_map() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html">unordered_map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a743946b3813b8ec54b762a6edbae2934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743946b3813b8ec54b762a6edbae2934">&#9670;&nbsp;</a></span>unordered_map() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html">unordered_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em> = <code><a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>__eql</em> = <code><a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code><a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor creates no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Minimal initial number of buckets. </td></tr>
    <tr><td class="paramname">__hf</td><td>A hash functor. </td></tr>
    <tr><td class="paramname">__eql</td><td>A key equality functor. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00151">151</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a94bb8e6f25731bdc01fb6c7b34022579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bb8e6f25731bdc01fb6c7b34022579">&#9670;&nbsp;</a></span>unordered_map() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html">unordered_map</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em> = <code><a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>__eql</em> = <code><a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code><a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an unordered_map from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>Minimal initial number of buckets. </td></tr>
    <tr><td class="paramname">__hf</td><td>A hash functor. </td></tr>
    <tr><td class="paramname">__eql</td><td>A key equality functor. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create an unordered_map consisting of copies of the elements from [__first,__last). This is linear in N (where N is distance(__first,__last)). </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00172">172</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a46d4ba7519835644688c2230f067a3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d4ba7519835644688c2230f067a3e8">&#9670;&nbsp;</a></span>unordered_map() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html">unordered_map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html">unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="a5924b32a6e46f9deb426e02e524f7d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5924b32a6e46f9deb426e02e524f7d23">&#9670;&nbsp;</a></span>unordered_map() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html">unordered_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html">unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<a id="ac2f6c6ba48b39f7e17b4760d809ebf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f6c6ba48b39f7e17b4760d809ebf26">&#9670;&nbsp;</a></span>unordered_map() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html">unordered_map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an unordered_map with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00191">191</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="acae490543303c7ea2365e5a53bc7d131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae490543303c7ea2365e5a53bc7d131">&#9670;&nbsp;</a></span>unordered_map() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::<a class="el" href="a08926.html">unordered_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em> = <code><a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>__eql</em> = <code><a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code><a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an unordered_map from an initializer_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list. </td></tr>
    <tr><td class="paramname">__n</td><td>Minimal initial number of buckets. </td></tr>
    <tr><td class="paramname">__hf</td><td>A hash functor. </td></tr>
    <tr><td class="paramname">__eql</td><td>A key equality functor. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create an unordered_map consisting of copies of the elements in the list. This is linear in N (where N is <em>__l.size()</em>). </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00227">227</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a801392267ec716837238015f8cefe60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801392267ec716837238015f8cefe60a">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a6d830d6d91653672a6f20b748327622b">mapped_type</a>&amp; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to unordered_map data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__k</td><td>The key for which data should be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the data whose key is equal to <em>__k</em>, if such a data is present in the unordered_map. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If no such data is present. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00996">996</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a1f78ebfeb9bf55bc807a075eb22cb2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f78ebfeb9bf55bc807a075eb22cb2aa">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a08926.html#a6d830d6d91653672a6f20b748327622b">mapped_type</a>&amp; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to unordered_map data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__k</td><td>The key for which data should be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the data whose key is equal to <em>__k</em>, if such a data is present in the unordered_map. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If no such data is present. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01000">1000</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a9d409d14c46998843b60af82785dfd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d409d14c46998843b60af82785dfd80">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the unordered_map. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00334">334</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ac90866b0f04d5366339b63f8e26bde06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90866b0f04d5366339b63f8e26bde06">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points to the first element in the unordered_map. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00325">325</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ae0eddd81ee3d218ade072a8becffaff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0eddd81ee3d218ade072a8becffaff6">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#aab940536a56eb520d8e7143ce5c4af3a">local_iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read/write iterator pointing to the first bucket element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read/write local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01041">1041</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a73cb0bbad75ff10a8493cdb155b81146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cb0bbad75ff10a8493cdb155b81146">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#af0cb2cf999f96def015e87c3cca6691d">const_local_iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to the first bucket element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01052">1052</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ac8a1a3c1d13adf8908c863a707fa40aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a1a3c1d13adf8908c863a707fa40aa">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of buckets of the unordered_map. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01008">1008</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="af9610ba94f6f17e7af50d7280638fa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9610ba94f6f17e7af50d7280638fa17">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the unordered_map. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00338">338</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a326f910adabc220031b93dc6b472b913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326f910adabc220031b93dc6b472b913">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#af0cb2cf999f96def015e87c3cca6691d">const_local_iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to the first bucket element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01056">1056</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ab862dadbaf3147cfc02bd383ed35e1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab862dadbaf3147cfc02bd383ed35e1f9">&#9670;&nbsp;</a></span>cend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the unordered_map. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00360">360</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00752_source.html#l00654">std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert_or_assign()</a>, and <a class="el" href="a00752_source.html#l00471">std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::try_emplace()</a>.</p>

</div>
</div>
<a id="a786093f27f238f88c21ecbfe11e27981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786093f27f238f88c21ecbfe11e27981">&#9670;&nbsp;</a></span>cend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#af0cb2cf999f96def015e87c3cca6691d">const_local_iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to one past the last bucket elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01082">1082</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a9728c777ec0429619531a26201560c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9728c777ec0429619531a26201560c18">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all elements in an unordered_map. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00790">790</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a66441bfe69a60ee7240a0dc2ceec7cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66441bfe69a60ee7240a0dc2ceec7cc9">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; decltype(_M_h._M_find_tr(__x), void(), true)
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds whether an element with the given key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of elements to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is any element with the specified key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00925">925</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a0a209f2b7b3109e8e5b6f96d64bec5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a209f2b7b3109e8e5b6f96d64bec5ab">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds whether an element with the given key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of elements to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is any element with the specified key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00920">920</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aeee86c62d9eeb17f046b8cae47ba8d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee86c62d9eeb17f046b8cae47ba8d12">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; decltype(_M_h._M_count_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with specified key.</dd></dl>
<p>This function only makes sense for unordered_multimap; for unordered_map the result will either be 0 (not present) or 1 (present). </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00907">907</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a4cbd19e5e859635c70822a7e1faa8e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbd19e5e859635c70822a7e1faa8e36">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with specified key.</dd></dl>
<p>This function only makes sense for unordered_multimap; for unordered_map the result will either be 0 (not present) or 1 (present). </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00901">901</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aa2c22cafc2b6f068358049c8fdb7bda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c22cafc2b6f068358049c8fdb7bda0">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">std::pair</a>&lt;<a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool&gt; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to build and insert a std::pair into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__args</td><td>Arguments used to generate a new pair instance (see std::piecewise_contruct for passing arguments to each part of the pair constructor).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</dd></dl>
<p>This function attempts to build and insert a (key, value) pair into the unordered_map. An unordered_map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the unordered_map.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00388">388</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="af36454c8cd5831988060bdf85a4d4d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36454c8cd5831988060bdf85a4d4d6e">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to build and insert a std::pair into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments used to generate a new pair instance (see std::piecewise_contruct for passing arguments to each part of the pair constructor). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of the std::pair built from <em>__args</em> (may or may not be that std::pair).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument emplace() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00419">419</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a4d72f478fb0cd05cc612e7ac746131ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d72f478fb0cd05cc612e7ac746131ac">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the unordered_map is empty. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00305">305</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a6b763e0c9c40786e19c26f5fa97e3ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b763e0c9c40786e19c26f5fa97e3ab6">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the unordered_map. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00356">356</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a42872e15c417c6f944d019315553951e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42872e15c417c6f944d019315553951e">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points one past the last element in the unordered_map. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00347">347</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ab91675efcde6f50894587cdb2037a4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91675efcde6f50894587cdb2037a4fc">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#aab940536a56eb520d8e7143ce5c4af3a">local_iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read/write iterator pointing to one past the last bucket elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read/write local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01067">1067</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a606977180c30d7a49a36846a45f4e355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606977180c30d7a49a36846a45f4e355">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#af0cb2cf999f96def015e87c3cca6691d">const_local_iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to one past the last bucket elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01078">1078</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a65c2c2c6bd08cf9a9b997e9ece957c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c2c2c6bd08cf9a9b997e9ece957c2a">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> -&gt; decltype(_M_h._M_equal_range_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function probably only makes sense for unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00947">947</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aca1f21a557b8cfe1e0a13a6fc2a4e34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1f21a557b8cfe1e0a13a6fc2a4e34c">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; decltype(_M_h._M_equal_range_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function probably only makes sense for unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00959">959</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a301e117827c134ed289b5d19e5c8a36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301e117827c134ed289b5d19e5c8a36e">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">std::pair</a>&lt;<a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&gt; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function probably only makes sense for unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00941">941</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a21e644ce722b02f5304757ea9be5b23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e644ce722b02f5304757ea9be5b23e">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">std::pair</a>&lt;<a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>, <a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&gt; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function probably only makes sense for unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00953">953</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a56149c061cd4aca92d631f7ad5a5a737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56149c061cd4aca92d631f7ad5a5a737">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases elements according to the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements erased.</dd></dl>
<p>This function erases all the elements located by the given key from an unordered_map. For an unordered_map the result of this function can only be 0 (not present) or 1 (present). Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00762">762</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a1b17775816c782568baefd357cd50e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b17775816c782568baefd357cd50e88">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases a [__first,__last) range of elements from an unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the start of the range to be erased. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to the end of the range to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator <em>__last</em>.</dd></dl>
<p>This function erases a sequence of elements from an unordered_map. Note that this function only erases the elements, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00780">780</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="adef61b0f6b1e43cfdb648e247277ba00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef61b0f6b1e43cfdb648e247277ba00">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an element from an unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator pointing to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element immediately following <em>__position</em> prior to the element being erased. If no such element exists, end() is returned.</dd></dl>
<p>This function erases an element, pointed to by the given iterator, from an unordered_map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00740">740</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ab04b983f5337e79f121f2df4bbaa283c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04b983f5337e79f121f2df4bbaa283c">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an element from an unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator pointing to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element immediately following <em>__position</em> prior to the element being erased. If no such element exists, end() is returned.</dd></dl>
<p>This function erases an element, pointed to by the given iterator, from an unordered_map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00745">745</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a0c23f11a0399cc6c5d5b0f798a347b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c23f11a0399cc6c5d5b0f798a347b93">&#9670;&nbsp;</a></span>extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_type <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a node. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00433">433</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a270ed38c6d0ca6a5b6469f01499e8241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270ed38c6d0ca6a5b6469f01499e8241">&#9670;&nbsp;</a></span>extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_type <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a node. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00425">425</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a161034f625211298037c2f470616a60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161034f625211298037c2f470616a60e">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> -&gt; decltype(_M_h._M_find_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in an unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00874">874</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a17871ecb708fe7527e0d02eb8a157fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17871ecb708fe7527e0d02eb8a157fe5">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Kt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const _Kt &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; decltype(_M_h._M_find_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in an unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00885">885</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ad62fc2387c4fa4aefe228c14239f8c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62fc2387c4fa4aefe228c14239f8c40">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in an unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00868">868</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a589217c1b2ed3f77f57aeb41d5192d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589217c1b2ed3f77f57aeb41d5192d0d">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in an unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00879">879</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a13808c3062786f090b1af63937f15963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13808c3062786f090b1af63937f15963">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a434ca8d37d3262f336f06903abbd170b">allocator_type</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator object used by the unordered_map. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00298">298</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ac9588299378201162e3f7da7e7d30fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9588299378201162e3f7da7e7d30fdf">&#9670;&nbsp;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a917dcd56682abf611f68cb72cbfb7d3e">hasher</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash functor object with which the unordered_map was constructed. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00844">844</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a0c40f8641ff4ca47fe2998a46404cf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c40f8641ff4ca47fe2998a46404cf37">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A template function that attempts to insert a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the start of the range to be inserted. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to the end of the range.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity similar to that of the range constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00616">616</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aae182defe617c8d37e27b27b09277ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae182defe617c8d37e27b27b09277ea9">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Pair &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__enable_if_t&lt;<a class="el" href="a04018.html">is_constructible</a>&lt;<a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a>, _Pair&amp;&amp;&gt;::value, <a class="el" href="a08610.html">pair</a>&lt;<a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool&gt; &gt; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">_Pair &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</dd></dl>
<p>This function attempts to insert a (key, value) pair into the unordered_map. An unordered_map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the unordered_map.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00563">563</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a047d2b3433747276ee6daa9eba154295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047d2b3433747276ee6daa9eba154295">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">std::pair</a>&lt;<a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool&gt; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</dd></dl>
<p>This function attempts to insert a (key, value) pair into the unordered_map. An unordered_map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the unordered_map.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00551">551</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ae4f015606d8e138c72eb87ce5f89ed50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f015606d8e138c72eb87ce5f89ed50">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Pair &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__enable_if_t&lt;<a class="el" href="a04018.html">is_constructible</a>&lt;<a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a>, _Pair&amp;&amp;&gt;::value, <a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>&gt; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Pair &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__hint</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00601">601</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a3eb7753105411145e2d8476cf300b348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb7753105411145e2d8476cf300b348">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__hint</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00590">590</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a01d23be5cd83c13117d269bc1df1488f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d23be5cd83c13117d269bc1df1488f">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__hint</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00596">596</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="a3d109f98534443c0d735545930ea0467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d109f98534443c0d735545930ea0467">&#9670;&nbsp;</a></span>insert() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__nh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-insert an extracted node. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00443">443</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="a191d1d95c2d102dc1057677df000aaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191d1d95c2d102dc1057677df000aaec">&#9670;&nbsp;</a></span>insert() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a list of elements into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>A std::initializer_list&lt;value_type&gt; of elements to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity similar to that of the range constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00627">627</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="af7886e783fd5c735bbe1bc8f685fea4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7886e783fd5c735bbe1bc8f685fea4b">&#9670;&nbsp;</a></span>insert() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">insert_return_type <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">node_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__nh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-insert an extracted node. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00438">438</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="adb80cc201b9b5b821e8ef73492106db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb80cc201b9b5b821e8ef73492106db3">&#9670;&nbsp;</a></span>insert() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">std::pair</a>&lt;<a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool&gt; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</dd></dl>
<p>This function attempts to insert a (key, value) pair into the unordered_map. An unordered_map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the unordered_map.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00557">557</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="a18c7292e78373e719791242496f23a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c7292e78373e719791242496f23a20">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">pair</a>&lt;<a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool&gt; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Obj &amp;&amp;&#160;</td>
          <td class="paramname"><em>__obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__k</td><td>Key to use for finding a possibly existing pair in the map. </td></tr>
    <tr><td class="paramname">__obj</td><td>Argument used to generate the .second for a pair instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</dd></dl>
<p>This function attempts to insert a (key, value) pair into the unordered_map. An unordered_map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the unordered_map. If the pair was already in the unordered_map, the .second of the pair is assigned from __obj.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00654">654</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00752_source.html#l00360">std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::cend()</a>.</p>

</div>
</div>
<a id="ac06399d585c8e22feecd02ddc7f16cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06399d585c8e22feecd02ddc7f16cd5">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Obj &amp;&amp;&#160;</td>
          <td class="paramname"><em>__obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a std::pair into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__hint</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__k</td><td>Key to use for finding a possibly existing pair in the unordered_map. </td></tr>
    <tr><td class="paramname">__obj</td><td>Argument used to generate the .second for a pair instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. <br  />
 If the pair was already in the unordered map, the .second of the pair is assigned from __obj. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00703">703</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aa956e7eb800e72fbab9b54f3ef006d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa956e7eb800e72fbab9b54f3ef006d8e">&#9670;&nbsp;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#aab5cec3a4b8e6f4030f5baeacf92edbc">key_equal</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the key comparison object with which the unordered_map was constructed. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00850">850</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="add961e22f4549e2c94846946fbd25a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add961e22f4549e2c94846946fbd25a7d">&#9670;&nbsp;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the average number of elements per bucket. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01090">1090</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="af29f5a18a09a36adb720b6907e45eacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29f5a18a09a36adb720b6907e45eacd">&#9670;&nbsp;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of buckets of the unordered_map. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01013">1013</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ae2f58d908f2e03656fce158550d9ba73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f58d908f2e03656fce158550d9ba73">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a positive number that the unordered_map tries to keep the load factor less than or equal to. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01096">1096</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a0584274b6378b6d962debbe96f5c5cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0584274b6378b6d962debbe96f5c5cb6">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>__z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the unordered_map maximum load factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__z</td><td>The new maximum load factor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01104">1104</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a695e48bcb2fa9e91ad07d3f7c45016dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695e48bcb2fa9e91ad07d3f7c45016dd">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum size of the unordered_map. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00315">315</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aca0525353d274a1abca19e123ca58702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0525353d274a1abca19e123ca58702">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html">unordered_map</a>&amp; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html">unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a id="a46087d4d85698c13e7fe5e10f13821d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46087d4d85698c13e7fe5e10f13821d1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html">unordered_map</a>&amp; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01878.html">initializer_list</a>&lt; <a class="el" href="a08926.html#af7e7d39b4a188c7aa535d0431ae8f14c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unordered_map list assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills an unordered_map with copies of the elements in the initializer list <em>__l</em>.</p>
<p>Note that the assignment completely changes the unordered_map and that the resulting unordered_map's size is the same as the number of elements assigned. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00290">290</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a7d63494d15ed6c47df072d06d9608ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d63494d15ed6c47df072d06d9608ca0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html">unordered_map</a>&amp; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html">unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a id="a2d7a21a98b09239b8745900308e63643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7a21a98b09239b8745900308e63643">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a6d830d6d91653672a6f20b748327622b">mapped_type</a>&amp; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript ( <code></code>[] ) access to unordered_map data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__k</td><td>The key for which data should be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the data of the (key,data) pair.</dd></dl>
<p>Allows for easy lookup with the subscript ( <code></code>[] )operator. Returns data associated with the key specified in subscript. If the key does not exist, a pair with that key is created using default values, which is then returned.</p>
<p>Lookup requires constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00979">979</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a21d659d8a7b18d41726d04ed6451d1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d659d8a7b18d41726d04ed6451d1ce">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a6d830d6d91653672a6f20b748327622b">mapped_type</a>&amp; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript ( <code></code>[] ) access to unordered_map data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__k</td><td>The key for which data should be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the data of the (key,data) pair.</dd></dl>
<p>Allows for easy lookup with the subscript ( <code></code>[] )operator. Returns data associated with the key specified in subscript. If the key does not exist, a pair with that key is created using default values, which is then returned.</p>
<p>Lookup requires constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00983">983</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00515_source.html#l00104">std::move()</a>.</p>

</div>
</div>
<a id="af81fbed78a715d3c81e8c7655669c7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81fbed78a715d3c81e8c7655669c7e7">&#9670;&nbsp;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>May rehash the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The new number of buckets.</td></tr>
  </table>
  </dd>
</dl>
<p>Rehash will occur only if the new number of buckets respect the unordered_map maximum load factor. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01115">1115</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a2eee23bd13796426f3018c8a9341202f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eee23bd13796426f3018c8a9341202f">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare the unordered_map for a specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Number of elements required.</td></tr>
  </table>
  </dd>
</dl>
<p>Same as rehash(ceil(n / max_load_factor())). </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l01126">1126</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a7d1de2c7389176716aceeaba3b1c2bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1de2c7389176716aceeaba3b1c2bb7">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#acefc3dbfc16b70562f92193d01156479">size_type</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the unordered_map. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00310">310</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ae06bac0d1fbee8603ec2ac806950b1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06bac0d1fbee8603ec2ac806950b1ba">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html">unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps data with another unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>An unordered_map of the same element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>This exchanges the elements between two unordered_map in constant time. Note that the global std::swap() function is specialized such that std::swap(m1,m2) will feed to this function. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00804">804</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a45bd22b39287d90f662a2fdc3517ab1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bd22b39287d90f662a2fdc3517ab1d">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08610.html">pair</a>&lt;<a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a>, bool&gt; <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to build and insert a std::pair into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__k</td><td>Key to use for finding a possibly existing pair in the unordered_map. </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments used to generate the .second for a new pair instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.</dd></dl>
<p>This function attempts to build and insert a (key, value) pair into the unordered_map. An unordered_map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the unordered_map. If a pair is not inserted, this function has no effect.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00471">471</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00752_source.html#l00360">std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::cend()</a>.</p>

</div>
</div>
<a id="a220092f3c52236249e8e904ff0906b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220092f3c52236249e8e904ff0906b41">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Hash  = hash&lt;_Key&gt;, typename _Pred  = equal_to&lt;_Key&gt;, typename _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08926.html#a0526d137ece77ce98d550cd2d6fd1816">iterator</a> <a class="el" href="a08926.html">std::unordered_map</a>&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08926.html#acb0e1b9ce26687d13dace99250f876e3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08926.html#ac563e7804340b706c3efeca91157585b">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to build and insert a std::pair into the unordered_map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__hint</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__k</td><td>Key to use for finding a possibly existing pair in the unordered_map. </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments used to generate the .second for a new pair instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of the std::pair built from <em>__args</em> (may or may not be that std::pair).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument emplace() does. However, if insertion did not take place, this function has no effect. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00752_source.html#l00515">515</a> of file <a class="el" href="a00752_source.html">unordered_map.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00752_source.html">unordered_map.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a01655.html">std</a></li><li class="navelem"><a class="el" href="a08926.html">unordered_map</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
