<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstdc++: Sorting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a01593.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sorting<div class="ingroups"><a class="el" href="a01590.html">Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Sorting:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01593.svg" width="371" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a01595"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01595.html">Binary Search</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01614"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01614.html">Heap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01594"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01594.html">Set Operations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga927cfd3e8df8c15df3fcec6c2af59a82"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ga927cfd3e8df8c15df3fcec6c2af59a82"><td class="memTemplItemLeft" align="right" valign="top">constexpr const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga927cfd3e8df8c15df3fcec6c2af59a82">std::clamp</a> (const _Tp &amp;__val, const _Tp &amp;__lo, const _Tp &amp;__hi)</td></tr>
<tr class="separator:ga927cfd3e8df8c15df3fcec6c2af59a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00e7d39a4bbac23967d87e1dbd763e1e"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:ga00e7d39a4bbac23967d87e1dbd763e1e"><td class="memTemplItemLeft" align="right" valign="top">constexpr const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga00e7d39a4bbac23967d87e1dbd763e1e">std::clamp</a> (const _Tp &amp;__val, const _Tp &amp;__lo, const _Tp &amp;__hi, _Compare __comp)</td></tr>
<tr class="separator:ga00e7d39a4bbac23967d87e1dbd763e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5479e1ac5e92b0c1f77bcf762d07e9"><td class="memTemplParams" colspan="2">template&lt;typename _BidirectionalIterator &gt; </td></tr>
<tr class="memitem:ga5e5479e1ac5e92b0c1f77bcf762d07e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga5e5479e1ac5e92b0c1f77bcf762d07e9">std::inplace_merge</a> (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)</td></tr>
<tr class="separator:ga5e5479e1ac5e92b0c1f77bcf762d07e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a8379ab8a648fd05d52ed0632081fa"><td class="memTemplParams" colspan="2">template&lt;typename _BidirectionalIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:gaf6a8379ab8a648fd05d52ed0632081fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gaf6a8379ab8a648fd05d52ed0632081fa">std::inplace_merge</a> (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)</td></tr>
<tr class="separator:gaf6a8379ab8a648fd05d52ed0632081fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a18da5fbc7d6f2b56f43156e13d02d2"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:ga3a18da5fbc7d6f2b56f43156e13d02d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga3a18da5fbc7d6f2b56f43156e13d02d2">std::is_sorted</a> (_ForwardIterator __first, _ForwardIterator __last)</td></tr>
<tr class="separator:ga3a18da5fbc7d6f2b56f43156e13d02d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2dd5c04be65e5bf5419776aeac1eda2"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:gae2dd5c04be65e5bf5419776aeac1eda2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gae2dd5c04be65e5bf5419776aeac1eda2">std::is_sorted</a> (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)</td></tr>
<tr class="separator:gae2dd5c04be65e5bf5419776aeac1eda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1373b346c799069f5c45c05993aeaf7f"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:ga1373b346c799069f5c45c05993aeaf7f"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga1373b346c799069f5c45c05993aeaf7f">std::is_sorted_until</a> (_ForwardIterator __first, _ForwardIterator __last)</td></tr>
<tr class="separator:ga1373b346c799069f5c45c05993aeaf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8cc41416bcbf277d408aa81bf1f051"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:ga1e8cc41416bcbf277d408aa81bf1f051"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga1e8cc41416bcbf277d408aa81bf1f051">std::is_sorted_until</a> (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)</td></tr>
<tr class="separator:ga1e8cc41416bcbf277d408aa81bf1f051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eff9effc89d8fd28bce9a6951b81f5d"><td class="memTemplParams" colspan="2">template&lt;typename _II1 , typename _II2 &gt; </td></tr>
<tr class="memitem:ga8eff9effc89d8fd28bce9a6951b81f5d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga8eff9effc89d8fd28bce9a6951b81f5d">std::lexicographical_compare</a> (_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)</td></tr>
<tr class="separator:ga8eff9effc89d8fd28bce9a6951b81f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd54bcbe68e78e8751c700263ae6ef5"><td class="memTemplParams" colspan="2">template&lt;typename _II1 , typename _II2 , typename _Compare &gt; </td></tr>
<tr class="memitem:ga9cd54bcbe68e78e8751c700263ae6ef5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga9cd54bcbe68e78e8751c700263ae6ef5">std::lexicographical_compare</a> (_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)</td></tr>
<tr class="separator:ga9cd54bcbe68e78e8751c700263ae6ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98f0838f871a26317aaa71211b65a9c"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:gab98f0838f871a26317aaa71211b65a9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gab98f0838f871a26317aaa71211b65a9c">std::max</a> (const _Tp &amp;__a, const _Tp &amp;__b)</td></tr>
<tr class="separator:gab98f0838f871a26317aaa71211b65a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd491cbbfc0452492f8fe4b7c3760b0d"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:gacd491cbbfc0452492f8fe4b7c3760b0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gacd491cbbfc0452492f8fe4b7c3760b0d">std::max</a> (const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)</td></tr>
<tr class="separator:gacd491cbbfc0452492f8fe4b7c3760b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf8e17bbc480ed6676ec0d1a326f4a05"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:gacf8e17bbc480ed6676ec0d1a326f4a05"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gacf8e17bbc480ed6676ec0d1a326f4a05">std::max_element</a> (_ForwardIterator __first, _ForwardIterator __last)</td></tr>
<tr class="separator:gacf8e17bbc480ed6676ec0d1a326f4a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672a1736a849c3f4675f4c13a3068884"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:ga672a1736a849c3f4675f4c13a3068884"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga672a1736a849c3f4675f4c13a3068884">std::max_element</a> (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)</td></tr>
<tr class="separator:ga672a1736a849c3f4675f4c13a3068884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d39bebd559751b145e409dd2e41ab1d"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </td></tr>
<tr class="memitem:ga0d39bebd559751b145e409dd2e41ab1d"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga0d39bebd559751b145e409dd2e41ab1d">std::merge</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)</td></tr>
<tr class="separator:ga0d39bebd559751b145e409dd2e41ab1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d075968551b0f77f71052e8832a5b88"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:ga7d075968551b0f77f71052e8832a5b88"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga7d075968551b0f77f71052e8832a5b88">std::merge</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)</td></tr>
<tr class="separator:ga7d075968551b0f77f71052e8832a5b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9cf068dc91c8779040669efa4a8cf65"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:gae9cf068dc91c8779040669efa4a8cf65"><td class="memTemplItemLeft" align="right" valign="top">constexpr const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gae9cf068dc91c8779040669efa4a8cf65">std::min</a> (const _Tp &amp;__a, const _Tp &amp;__b)</td></tr>
<tr class="separator:gae9cf068dc91c8779040669efa4a8cf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7909b7a198cc9c418432b4b2b138cac1"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:ga7909b7a198cc9c418432b4b2b138cac1"><td class="memTemplItemLeft" align="right" valign="top">constexpr const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga7909b7a198cc9c418432b4b2b138cac1">std::min</a> (const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)</td></tr>
<tr class="separator:ga7909b7a198cc9c418432b4b2b138cac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc18030e0f9d1b83be2e8f0718fe72c"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:ga1bc18030e0f9d1b83be2e8f0718fe72c"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga1bc18030e0f9d1b83be2e8f0718fe72c">std::min_element</a> (_ForwardIterator __first, _ForwardIterator __last)</td></tr>
<tr class="separator:ga1bc18030e0f9d1b83be2e8f0718fe72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c580be620f774d1b197c9db950b42ce"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:ga0c580be620f774d1b197c9db950b42ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr _ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga0c580be620f774d1b197c9db950b42ce">std::min_element</a> (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)</td></tr>
<tr class="separator:ga0c580be620f774d1b197c9db950b42ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02c72c1390894648ba6d61ab8990db6"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:gae02c72c1390894648ba6d61ab8990db6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08610.html">pair</a>&lt; const _Tp &amp;, const _Tp &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gae02c72c1390894648ba6d61ab8990db6">std::minmax</a> (const _Tp &amp;__a, const _Tp &amp;__b)</td></tr>
<tr class="separator:gae02c72c1390894648ba6d61ab8990db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad98dfb06baec2f6d60027e169853a05d"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , typename _Compare &gt; </td></tr>
<tr class="memitem:gad98dfb06baec2f6d60027e169853a05d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08610.html">pair</a>&lt; const _Tp &amp;, const _Tp &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gad98dfb06baec2f6d60027e169853a05d">std::minmax</a> (const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)</td></tr>
<tr class="separator:gad98dfb06baec2f6d60027e169853a05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae0b4df34a950ed0c4f9f57cd9180f6"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:gafae0b4df34a950ed0c4f9f57cd9180f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08610.html">pair</a>&lt; _ForwardIterator, _ForwardIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gafae0b4df34a950ed0c4f9f57cd9180f6">std::minmax_element</a> (_ForwardIterator __first, _ForwardIterator __last)</td></tr>
<tr class="separator:gafae0b4df34a950ed0c4f9f57cd9180f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aced643e81b2410a783b9795b9bde0e"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:ga5aced643e81b2410a783b9795b9bde0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08610.html">pair</a>&lt; _ForwardIterator, _ForwardIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga5aced643e81b2410a783b9795b9bde0e">std::minmax_element</a> (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)</td></tr>
<tr class="separator:ga5aced643e81b2410a783b9795b9bde0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cce728835fcad7eed2570eb759131d8"><td class="memTemplParams" colspan="2">template&lt;typename _BidirectionalIterator &gt; </td></tr>
<tr class="memitem:ga7cce728835fcad7eed2570eb759131d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga7cce728835fcad7eed2570eb759131d8">std::next_permutation</a> (_BidirectionalIterator __first, _BidirectionalIterator __last)</td></tr>
<tr class="separator:ga7cce728835fcad7eed2570eb759131d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820"><td class="memTemplParams" colspan="2">template&lt;typename _BidirectionalIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820">std::next_permutation</a> (_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)</td></tr>
<tr class="separator:ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d11e737b96371885931c3ba8e3645e"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIterator &gt; </td></tr>
<tr class="memitem:gad2d11e737b96371885931c3ba8e3645e"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gad2d11e737b96371885931c3ba8e3645e">std::nth_element</a> (_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)</td></tr>
<tr class="separator:gad2d11e737b96371885931c3ba8e3645e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b77881d58e25fdfd0536dc100bfe635"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:ga0b77881d58e25fdfd0536dc100bfe635"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga0b77881d58e25fdfd0536dc100bfe635">std::nth_element</a> (_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)</td></tr>
<tr class="separator:ga0b77881d58e25fdfd0536dc100bfe635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga268b5bc10a3f5dac87c6e6e547e70f88"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga268b5bc10a3f5dac87c6e6e547e70f88"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga268b5bc10a3f5dac87c6e6e547e70f88">std::partial_sort</a> (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)</td></tr>
<tr class="separator:ga268b5bc10a3f5dac87c6e6e547e70f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0a8c56ac512c78bbf5ccee6de8539b"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:gaca0a8c56ac512c78bbf5ccee6de8539b"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gaca0a8c56ac512c78bbf5ccee6de8539b">std::partial_sort</a> (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)</td></tr>
<tr class="separator:gaca0a8c56ac512c78bbf5ccee6de8539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga071176a89f62f2c99841332f9fd9aa0f"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga071176a89f62f2c99841332f9fd9aa0f"><td class="memTemplItemLeft" align="right" valign="top">constexpr _RandomAccessIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga071176a89f62f2c99841332f9fd9aa0f">std::partial_sort_copy</a> (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)</td></tr>
<tr class="separator:ga071176a89f62f2c99841332f9fd9aa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97179dae819b2c8f96367a14d3607bc4"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _RandomAccessIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:ga97179dae819b2c8f96367a14d3607bc4"><td class="memTemplItemLeft" align="right" valign="top">constexpr _RandomAccessIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga97179dae819b2c8f96367a14d3607bc4">std::partial_sort_copy</a> (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)</td></tr>
<tr class="separator:ga97179dae819b2c8f96367a14d3607bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8521ac56216e486d761d239b2d59085e"><td class="memTemplParams" colspan="2">template&lt;typename _BidirectionalIterator &gt; </td></tr>
<tr class="memitem:ga8521ac56216e486d761d239b2d59085e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga8521ac56216e486d761d239b2d59085e">std::prev_permutation</a> (_BidirectionalIterator __first, _BidirectionalIterator __last)</td></tr>
<tr class="separator:ga8521ac56216e486d761d239b2d59085e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1304617e63648825d90a5e186d41fbe"><td class="memTemplParams" colspan="2">template&lt;typename _BidirectionalIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:gaf1304617e63648825d90a5e186d41fbe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gaf1304617e63648825d90a5e186d41fbe">std::prev_permutation</a> (_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)</td></tr>
<tr class="separator:gaf1304617e63648825d90a5e186d41fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56b01b6148c1610ce928e662a5e97f0f"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga56b01b6148c1610ce928e662a5e97f0f"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga56b01b6148c1610ce928e662a5e97f0f">std::sort</a> (_RandomAccessIterator __first, _RandomAccessIterator __last)</td></tr>
<tr class="separator:ga56b01b6148c1610ce928e662a5e97f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf82f396bc6a1d4a9209e2aade9a57a39"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:gaf82f396bc6a1d4a9209e2aade9a57a39"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#gaf82f396bc6a1d4a9209e2aade9a57a39">std::sort</a> (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)</td></tr>
<tr class="separator:gaf82f396bc6a1d4a9209e2aade9a57a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8bb8e52b7b0e80301dcbec17225b4a"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga7d8bb8e52b7b0e80301dcbec17225b4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga7d8bb8e52b7b0e80301dcbec17225b4a">std::stable_sort</a> (_RandomAccessIterator __first, _RandomAccessIterator __last)</td></tr>
<tr class="separator:ga7d8bb8e52b7b0e80301dcbec17225b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3ce3aa8ac2297f8290939a7988596d"><td class="memTemplParams" colspan="2">template&lt;typename _RandomAccessIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:ga3a3ce3aa8ac2297f8290939a7988596d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01593.html#ga3a3ce3aa8ac2297f8290939a7988596d">std::stable_sort</a> (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)</td></tr>
<tr class="separator:ga3a3ce3aa8ac2297f8290939a7988596d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga927cfd3e8df8c15df3fcec6c2af59a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga927cfd3e8df8c15df3fcec6c2af59a82">&#9670;&nbsp;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const _Tp &amp; std::clamp </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value clamped between lo and hi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__val</td><td>A value of arbitrary type. </td></tr>
    <tr><td class="paramname">__lo</td><td>A lower limit of arbitrary type. </td></tr>
    <tr><td class="paramname">__hi</td><td>An upper limit of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;tt&gt;__lo&lt;/tt&gt;</td><td>if <code>__val &lt; __lo</code> </td></tr>
    <tr><td class="paramname">&lt;tt&gt;__hi&lt;/tt&gt;</td><td>if <code>__hi &lt; __val</code> </td></tr>
    <tr><td class="paramname">&lt;tt&gt;__val&lt;/tt&gt;</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>_Tp</code> is LessThanComparable and <code>(__hi &lt; __lo)</code> is false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03621">3621</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga00e7d39a4bbac23967d87e1dbd763e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00e7d39a4bbac23967d87e1dbd763e1e">&#9670;&nbsp;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const _Tp &amp; std::clamp </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value clamped between lo and hi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__val</td><td>A value of arbitrary type. </td></tr>
    <tr><td class="paramname">__lo</td><td>A lower limit of arbitrary type. </td></tr>
    <tr><td class="paramname">__hi</td><td>An upper limit of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;tt&gt;__lo&lt;/tt&gt;</td><td>if <code>__comp(__val, __lo)</code> </td></tr>
    <tr><td class="paramname">&lt;tt&gt;__hi&lt;/tt&gt;</td><td>if <code>__comp(__hi, __val)</code> </td></tr>
    <tr><td class="paramname">&lt;tt&gt;__val&lt;/tt&gt;</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>__comp(__hi, __lo)</code> is false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03641">3641</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga5e5479e1ac5e92b0c1f77bcf762d07e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e5479e1ac5e92b0c1f77bcf762d07e9">&#9670;&nbsp;</a></span>inplace_merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::inplace_merge </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sorted ranges in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Merges two sorted and consecutive ranges, [__first,__middle) and [__middle,__last), and puts the result in [__first,__last). The output will be sorted. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>If enough additional memory is available, this takes (__last-__first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(__first,__last). </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l02550">2550</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaf6a8379ab8a648fd05d52ed0632081fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6a8379ab8a648fd05d52ed0632081fa">&#9670;&nbsp;</a></span>inplace_merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::inplace_merge </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sorted ranges in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Merges two sorted and consecutive ranges, [__first,__middle) and [middle,last), and puts the result in [__first,__last). The output will be sorted. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>If enough additional memory is available, this takes (__last-__first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(__first,__last).</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l02591">2591</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga3a18da5fbc7d6f2b56f43156e13d02d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a18da5fbc7d6f2b56f43156e13d02d2">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::is_sorted </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of a sequence are sorted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the elements are sorted, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03187">3187</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gae2dd5c04be65e5bf5419776aeac1eda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2dd5c04be65e5bf5419776aeac1eda2">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::is_sorted </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of a sequence are sorted according to a comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the elements are sorted, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03202">3202</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga1373b346c799069f5c45c05993aeaf7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1373b346c799069f5c45c05993aeaf7f">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator std::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the end of a sorted sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the last iterator i in [__first, __last) for which the range [__first, i) is sorted. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03233">3233</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga1e8cc41416bcbf277d408aa81bf1f051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e8cc41416bcbf277d408aa81bf1f051">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator std::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the end of a sorted sequence using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the last iterator i in [__first, __last) for which the range [__first, i) is sorted. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03258">3258</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga8eff9effc89d8fd28bce9a6951b81f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eff9effc89d8fd28bce9a6951b81f5d">&#9670;&nbsp;</a></span>lexicographical_compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _II1 , typename _II2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs <b>dictionary</b> comparison on ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p><em>Returns true if the sequence of elements defined by the range [first1,last1) is lexicographically less than the sequence of elements defined by the range [first2,last2). Returns false otherwise.</em> (Quoted from [25.3.8]/1.) If the iterators are all character pointers, then this is an inline call to <code>memcmp</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l01731">1731</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="ga9cd54bcbe68e78e8751c700263ae6ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cd54bcbe68e78e8751c700263ae6ef5">&#9670;&nbsp;</a></span>lexicographical_compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _II1 , typename _II2 , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs <b>dictionary</b> comparison on ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="a01609.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>The same as the four-parameter <code>lexicographical_compare</code>, but uses the comp parameter instead of <code>&lt;</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l01766">1766</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gab98f0838f871a26317aaa71211b65a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab98f0838f871a26317aaa71211b65a9c">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const _Tp &amp; std::max </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greater of the parameters.</dd></dl>
<p>This is the simple classic generic implementation. It will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l00254">254</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00662_source.html#l00639">std::_Deque_base&lt; _Tp, _Alloc &gt;::_M_initialize_map()</a>, <a class="el" href="a00401_source.html#l00932">std::deque&lt; _Tp, _Alloc &gt;::_M_reallocate_map()</a>, <a class="el" href="a19807_source.html#l00844">std::shuffle_order_engine&lt; _RandomNumberEngine, __k &gt;::operator()()</a>, and <a class="el" href="a00635_source.html#l00080">std::basic_stringbuf&lt; _CharT, _Traits, _Alloc &gt;::overflow()</a>.</p>

</div>
</div>
<a id="gacd491cbbfc0452492f8fe4b7c3760b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd491cbbfc0452492f8fe4b7c3760b0d">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const _Tp &amp; std::max </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="a01609.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greater of the parameters.</dd></dl>
<p>This will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l00300">300</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gacf8e17bbc480ed6676ec0d1a326f4a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf8e17bbc480ed6676ec0d1a326f4a05">&#9670;&nbsp;</a></span>max_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator std::max_element </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum element in a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the largest value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l05681">5681</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga672a1736a849c3f4675f4c13a3068884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga672a1736a849c3f4675f4c13a3068884">&#9670;&nbsp;</a></span>max_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator std::max_element </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum element in a range using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the largest value according to __comp. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l05706">5706</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga0d39bebd559751b145e409dd2e41ab1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d39bebd559751b145e409dd2e41ab1d">&#9670;&nbsp;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::merge </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sorted ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An iterator pointing to the end of the merged range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>__result</code> + (__last1 - __first1)<ul>
<li>(__last2 - __first2).</li>
</ul>
</dd></dl>
<p>Merges the ranges <code></code>[__first1,__last1) and <code></code>[__first2,__last2) into the sorted range <code></code>[__result, __result + (__last1-__first1) + (__last2-__first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04905">4905</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga7d075968551b0f77f71052e8832a5b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d075968551b0f77f71052e8832a5b88">&#9670;&nbsp;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::merge </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sorted ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An iterator pointing to the end of the merged range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>__result</code> + (__last1 - __first1)<ul>
<li>(__last2 - __first2).</li>
</ul>
</dd></dl>
<p>Merges the ranges <code></code>[__first1,__last1) and <code></code>[__first2,__last2) into the sorted range <code></code>[__result, __result + (__last1-__first1) + (__last2-__first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04956">4956</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gae9cf068dc91c8779040669efa4a8cf65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9cf068dc91c8779040669efa4a8cf65">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const _Tp &amp; std::min </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lesser of the parameters.</dd></dl>
<p>This is the simple classic generic implementation. It will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l00230">230</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00650_source.html#l05796">std::__sample()</a>, <a class="el" href="a01043_source.html#l00081">__gnu_parallel::__search_template()</a>, <a class="el" href="a01196_source.html#l02075">__gnu_cxx::__versa_string&lt; _CharT, _Traits, _Alloc, _Base &gt;::compare()</a>, <a class="el" href="a00365_source.html#l00854">std::basic_string&lt; _CharT, _Traits, _Alloc &gt;::compare()</a>, <a class="el" href="a19807_source.html#l03354">std::generate_canonical()</a>, <a class="el" href="a19807_source.html#l00844">std::shuffle_order_engine&lt; _RandomNumberEngine, __k &gt;::operator()()</a>, <a class="el" href="a00635_source.html#l00080">std::basic_stringbuf&lt; _CharT, _Traits, _Alloc &gt;::overflow()</a>, <a class="el" href="a00728_source.html#l00046">std::basic_streambuf&lt; _CharT, _Traits &gt;::xsgetn()</a>, <a class="el" href="a00437_source.html#l00756">std::basic_filebuf&lt; _CharT, _Traits &gt;::xsputn()</a>, and <a class="el" href="a00728_source.html#l00080">std::basic_streambuf&lt; _CharT, _Traits &gt;::xsputn()</a>.</p>

</div>
</div>
<a id="ga7909b7a198cc9c418432b4b2b138cac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7909b7a198cc9c418432b4b2b138cac1">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const _Tp &amp; std::min </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="a01609.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lesser of the parameters.</dd></dl>
<p>This will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

<p class="definition">Definition at line <a class="el" href="a00653_source.html#l00278">278</a> of file <a class="el" href="a00653_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="ga1bc18030e0f9d1b83be2e8f0718fe72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bc18030e0f9d1b83be2e8f0718fe72c">&#9670;&nbsp;</a></span>min_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator std::min_element </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum element in a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the smallest value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l05617">5617</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga0c580be620f774d1b197c9db950b42ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c580be620f774d1b197c9db950b42ce">&#9670;&nbsp;</a></span>min_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _ForwardIterator std::min_element </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum element in a range using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the smallest value according to __comp. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l05642">5642</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gae02c72c1390894648ba6d61ab8990db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae02c72c1390894648ba6d61ab8990db6">&#9670;&nbsp;</a></span>minmax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08610.html">pair</a>&lt; const _Tp &amp;, const _Tp &amp; &gt; std::minmax </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines min and max at once as an ordered pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair(__b, __a) if __b is smaller than __a, pair(__a, __b) otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03284">3284</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gad98dfb06baec2f6d60027e169853a05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad98dfb06baec2f6d60027e169853a05d">&#9670;&nbsp;</a></span>minmax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08610.html">pair</a>&lt; const _Tp &amp;, const _Tp &amp; &gt; std::minmax </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines min and max at once as an ordered pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="a01609.html">comparison functor </a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair(__b, __a) if __b is smaller than __a, pair(__a, __b) otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03305">3305</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gafae0b4df34a950ed0c4f9f57cd9180f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafae0b4df34a950ed0c4f9f57cd9180f6">&#9670;&nbsp;</a></span>minmax_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08610.html">pair</a>&lt;_ForwardIterator, _ForwardIterator&gt; std::minmax_element </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pair of iterators pointing to the minimum and maximum elements in a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>make_pair(m, M), where m is the first iterator i in [__first, __last) such that no other element in the range is smaller, and where M is the last iterator i in [__first, __last) such that no other element in the range is larger. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03385">3385</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga5aced643e81b2410a783b9795b9bde0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aced643e81b2410a783b9795b9bde0e">&#9670;&nbsp;</a></span>minmax_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08610.html">pair</a>&lt;_ForwardIterator, _ForwardIterator&gt; std::minmax_element </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pair of iterators pointing to the minimum and maximum elements in a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>make_pair(m, M), where m is the first iterator i in [__first, __last) such that no other element in the range is smaller, and where M is the last iterator i in [__first, __last) such that no other element in the range is larger. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03413">3413</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga7cce728835fcad7eed2570eb759131d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cce728835fcad7eed2570eb759131d8">&#9670;&nbsp;</a></span>next_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::next_permutation </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute range into the next <em>dictionary</em> ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to first permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range as a set of <em>dictionary</em> sorted sequences. Permutes the current sequence into the next one of this set. Returns true if there are more sequences to generate. If the sequence is the largest of the set, the smallest is generated and false returned. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l02935">2935</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820">&#9670;&nbsp;</a></span>next_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::next_permutation </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute range into the next <em>dictionary</em> ordering using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to first permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range [__first,__last) as a set of <em>dictionary</em> sorted sequences ordered by <code>__comp</code>. Permutes the current sequence into the next one of this set. Returns true if there are more sequences to generate. If the sequence is the largest of the set, the smallest is generated and false returned. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l02968">2968</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gad2d11e737b96371885931c3ba8e3645e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2d11e737b96371885931c3ba8e3645e">&#9670;&nbsp;</a></span>nth_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void std::nth_element </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort a sequence just enough to find a particular position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Rearranges the elements in the range <code></code>[__first,__last) so that <code>*__nth</code> is the same element that would have been in that position had the whole sequence been sorted. The elements either side of <code>*__nth</code> are not completely sorted, but for any iterator <em>i</em> in the range <code></code>[__first,__nth) and any iterator <em>j</em> in the range <code></code>[__nth,__last) it holds that *j &lt; *i is false. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04732">4732</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga0b77881d58e25fdfd0536dc100bfe635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b77881d58e25fdfd0536dc100bfe635">&#9670;&nbsp;</a></span>nth_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void std::nth_element </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort a sequence just enough to find a particular position using a predicate for comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Rearranges the elements in the range <code></code>[__first,__last) so that <code>*__nth</code> is the same element that would have been in that position had the whole sequence been sorted. The elements either side of <code>*__nth</code> are not completely sorted, but for any iterator <em>i</em> in the range <code></code>[__first,__nth) and any iterator <em>j</em> in the range <code></code>[__nth,__last) it holds that <code>__comp(*j,*i)</code> is false. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04772">4772</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga268b5bc10a3f5dac87c6e6e547e70f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga268b5bc10a3f5dac87c6e6e547e70f88">&#9670;&nbsp;</a></span>partial_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void std::partial_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the smallest elements of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the smallest <code></code>(__middle-__first) elements in the range <code></code>[first,last) and moves them to the range <code></code>[__first,__middle). The order of the remaining elements in the range <code></code>[__middle,__last) is undefined. After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__first,__middle) such that i precedes j and <em>k</em> is an iterator in the range <code></code>[__middle,__last) then *j&lt;*i and *k&lt;*i are both false. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04656">4656</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaca0a8c56ac512c78bbf5ccee6de8539b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca0a8c56ac512c78bbf5ccee6de8539b">&#9670;&nbsp;</a></span>partial_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void std::partial_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the smallest elements of a sequence using a predicate for comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the smallest <code></code>(__middle-__first) elements in the range <code></code>[__first,__last) and moves them to the range <code></code>[__first,__middle). The order of the remaining elements in the range <code></code>[__middle,__last) is undefined. After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__first,__middle) such that i precedes j and <em>k</em> is an iterator in the range <code></code>[__middle,__last) then <code>*__comp</code>(j,*i) and <code>__comp(*k,*i)</code> are both false. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04695">4695</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga071176a89f62f2c99841332f9fd9aa0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga071176a89f62f2c99841332f9fd9aa0f">&#9670;&nbsp;</a></span>partial_sort_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _RandomAccessIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _RandomAccessIterator std::partial_sort_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__result_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__result_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the smallest elements of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">__result_last</td><td>Another random-access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator indicating the end of the resulting sequence.</dd></dl>
<p>Copies and sorts the smallest N values from the range <code></code>[__first,__last) to the range beginning at <code>__result_first</code>, where the number of elements to be copied, <code>N</code>, is the smaller of <code></code>(__last-__first) and <code></code>(__result_last-__result_first). After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__result_first,__result_first+N) such that i precedes j then *j&lt;*i is false. The value returned is <code>__result_first+N</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l01696">1696</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga97179dae819b2c8f96367a14d3607bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97179dae819b2c8f96367a14d3607bc4">&#9670;&nbsp;</a></span>partial_sort_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _RandomAccessIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _RandomAccessIterator std::partial_sort_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__result_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__result_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the smallest elements of a sequence using a predicate for comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another input iterator. </td></tr>
    <tr><td class="paramname">__result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">__result_last</td><td>Another random-access iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator indicating the end of the resulting sequence.</dd></dl>
<p>Copies and sorts the smallest N values from the range <code></code>[__first,__last) to the range beginning at <code>result_first</code>, where the number of elements to be copied, <code>N</code>, is the smaller of <code></code>(__last-__first) and <code></code>(__result_last-__result_first). After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__result_first,__result_first+N) such that i precedes j then <code>__comp(*j,*i)</code> is false. The value returned is <code>__result_first+N</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l01747">1747</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga8521ac56216e486d761d239b2d59085e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8521ac56216e486d761d239b2d59085e">&#9670;&nbsp;</a></span>prev_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::prev_permutation </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute range into the previous <em>dictionary</em> ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to last permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range as a set of <em>dictionary</em> sorted sequences. Permutes the current sequence into the previous one of this set. Returns true if there are more sequences to generate. If the sequence is the smallest of the set, the largest is generated and false returned. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03038">3038</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaf1304617e63648825d90a5e186d41fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1304617e63648825d90a5e186d41fbe">&#9670;&nbsp;</a></span>prev_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::prev_permutation </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute range into the previous <em>dictionary</em> ordering using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to last permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range [__first,__last) as a set of <em>dictionary</em> sorted sequences ordered by <code>__comp</code>. Permutes the current sequence into the previous one of this set. Returns true if there are more sequences to generate. If the sequence is the smallest of the set, the largest is generated and false returned. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l03071">3071</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga56b01b6148c1610ce928e662a5e97f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56b01b6148c1610ce928e662a5e97f0f">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void std::sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the elements of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <em>i</em> in the range <code></code>[__first,__last-1), <br  />
 *(i+1)&lt;*i is false.</p>
<p>The relative ordering of equivalent elements is not preserved, use <code>stable_sort()</code> if this is needed. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04810">4810</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaf82f396bc6a1d4a9209e2aade9a57a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf82f396bc6a1d4a9209e2aade9a57a39">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void std::sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the elements of a sequence using a predicate for comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that <code>__comp</code>(*(i+1),*i) is false for every iterator <em>i</em> in the range <code></code>[__first,__last-1).</p>
<p>The relative ordering of equivalent elements is not preserved, use <code>stable_sort()</code> if this is needed. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l04841">4841</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga7d8bb8e52b7b0e80301dcbec17225b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d8bb8e52b7b0e80301dcbec17225b4a">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::stable_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the elements of a sequence, preserving the relative order of equivalent elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <code>i</code> in the range <code></code>[__first,__last-1), <code>*</code>(i+1)&lt;*i is false.</p>
<p>The relative ordering of equivalent elements is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>x&lt;y</code> is false and <code>y&lt;x</code> is false will have the same relative ordering after calling <code>stable_sort()</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l05024">5024</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga3a3ce3aa8ac2297f8290939a7988596d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a3ce3aa8ac2297f8290939a7988596d">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::stable_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the elements of a sequence using a predicate for comparison, preserving the relative order of equivalent elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <code>i</code> in the range <code></code>[__first,__last-1), <code>__comp</code>(*(i+1),*i) is false.</p>
<p>The relative ordering of equivalent elements is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>__comp(x,y)</code> is false and <code>__comp(y,x)</code> is false will have the same relative ordering after calling <code>stable_sort()</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00650_source.html#l05058">5058</a> of file <a class="el" href="a00650_source.html">stl_algo.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
